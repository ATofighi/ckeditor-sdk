<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='global-property-use strict'>/**
</span> * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or http://ckeditor.com/license
 */

&#39;use strict&#39;;

<span id='CKEDITOR-editor-method-attachStyleStateChange'>/**
</span> * Registers a function to be called whenever the selection position changes in the
 * editing area. The current state is passed to the function. The possible
 * states are {@link CKEDITOR#TRISTATE_ON} and {@link CKEDITOR#TRISTATE_OFF}.
 *
 *		// Create a style object for the &lt;b&gt; element.
 *		var style = new CKEDITOR.style( { element: &#39;b&#39; } );
 *		var editor = CKEDITOR.instances.editor1;
 *		editor.attachStyleStateChange( style, function( state ) {
 *			if ( state == CKEDITOR.TRISTATE_ON )
 *				alert( &#39;The current state for the B element is ON&#39; );
 *			else
 *				alert( &#39;The current state for the B element is OFF&#39; );
 *		} );
 *
 * @member CKEDITOR.editor
 * @param {CKEDITOR.style} style The style to be watched.
 * @param {Function} callback The function to be called.
 */
CKEDITOR.editor.prototype.attachStyleStateChange = function( style, callback ) {
	// Try to get the list of attached callbacks.
	var styleStateChangeCallbacks = this._.styleStateChangeCallbacks;

	// If it doesn&#39;t exist, it means this is the first call. So, let&#39;s create
	// all the structure to manage the style checks and the callback calls.
	if ( !styleStateChangeCallbacks ) {
		// Create the callbacks array.
		styleStateChangeCallbacks = this._.styleStateChangeCallbacks = [];

		// Attach to the selectionChange event, so we can check the styles at
		// that point.
		this.on( &#39;selectionChange&#39;, function( ev ) {
			// Loop throw all registered callbacks.
			for ( var i = 0; i &lt; styleStateChangeCallbacks.length; i++ ) {
				var callback = styleStateChangeCallbacks[ i ];

				// Check the current state for the style defined for that callback.
				var currentState = callback.style.checkActive( ev.data.path ) ?
					CKEDITOR.TRISTATE_ON : CKEDITOR.TRISTATE_OFF;

				// Call the callback function, passing the current state to it.
				callback.fn.call( this, currentState );
			}
		} );
	}

	// Save the callback info, so it can be checked on the next occurrence of
	// selectionChange.
	styleStateChangeCallbacks.push( { style: style, fn: callback } );
};

CKEDITOR.STYLE_BLOCK = 1;
CKEDITOR.STYLE_INLINE = 2;
CKEDITOR.STYLE_OBJECT = 3;

( function() {
	var blockElements = { address: 1, div: 1, h1: 1, h2: 1, h3: 1, h4: 1, h5: 1, h6: 1, p: 1,
			pre: 1, section: 1, header: 1, footer: 1, nav: 1, article: 1, aside: 1, figure: 1,
			dialog: 1, hgroup: 1, time: 1, meter: 1, menu: 1, command: 1, keygen: 1, output: 1,
			progress: 1, details: 1, datagrid: 1, datalist: 1 },

		objectElements = { a: 1, embed: 1, hr: 1, img: 1, li: 1, object: 1, ol: 1, table: 1, td: 1,
			tr: 1, th: 1, ul: 1, dl: 1, dt: 1, dd: 1, form: 1, audio: 1, video: 1 };

	var semicolonFixRegex = /\s*(?:;\s*|$)/,
		varRegex = /#\((.+?)\)/g;

	var notBookmark = CKEDITOR.dom.walker.bookmark( 0, 1 ),
		nonWhitespaces = CKEDITOR.dom.walker.whitespaces( 1 );

<span id='CKEDITOR-style-method-constructor'><span id='CKEDITOR-style'>	/**
</span></span>	 * TODO...
	 *
	 * @class
	 * @constructor Creates a style class instance.
	 * @param styleDefinition
	 * @param variablesValues
	 * @todo
	 */
	CKEDITOR.style = function( styleDefinition, variablesValues ) {

		// Inline style text as attribute should be converted
		// to styles object.
		var attrs = styleDefinition.attributes;
		if ( attrs &amp;&amp; attrs.style ) {
			styleDefinition.styles = CKEDITOR.tools.extend( {},
				styleDefinition.styles, CKEDITOR.tools.parseCssText( attrs.style ) );
			delete attrs.style;
		}

		if ( variablesValues ) {
			styleDefinition = CKEDITOR.tools.clone( styleDefinition );

			replaceVariables( styleDefinition.attributes, variablesValues );
			replaceVariables( styleDefinition.styles, variablesValues );
		}

		var element = this.element = styleDefinition.element ?
			(
				typeof styleDefinition.element == &#39;string&#39; ?
					styleDefinition.element.toLowerCase() : styleDefinition.element
			) : &#39;*&#39;;

		this.type = styleDefinition.type ||
			(
				blockElements[ element ] ? CKEDITOR.STYLE_BLOCK :
				objectElements[ element ] ? CKEDITOR.STYLE_OBJECT :
				CKEDITOR.STYLE_INLINE
			);

		// If the &#39;element&#39; property is an object with a set of possible element, it will be applied like an object style: only to existing elements
		if ( typeof this.element == &#39;object&#39; )
			this.type = CKEDITOR.STYLE_OBJECT;

		this._ = {
			definition: styleDefinition
		};
	};

<span id='CKEDITOR-editor-method-applyStyle'>	/**
</span>	 * Apply the style upon the editor&#39;s current selection.
	 *
	 * @member CKEDITOR.editor
	 * @param {CKEDITOR.style} style
	 */
	CKEDITOR.editor.prototype.applyStyle = function( style ) {
		if ( style.checkApplicable( this.elementPath() ) )
			applyStyleOnSelection.call( style, this.getSelection() );
	};

<span id='CKEDITOR-editor-method-removeStyle'>	/**
</span>	 * Remove the style from the editor&#39;s current selection.
	 *
	 * @member CKEDITOR.editor
	 * @param {CKEDITOR.style} style
	 */
	CKEDITOR.editor.prototype.removeStyle = function( style ) {
		if ( style.checkApplicable( this.elementPath() ) )
			applyStyleOnSelection.call( style, this.getSelection(), 1 );
	};

	CKEDITOR.style.prototype = {
<span id='CKEDITOR-style-method-apply'>		/**
</span>		 * @param {CKEDITOR.dom.document} document
		 * @todo
		 */
		apply: function( document ) {
			applyStyleOnSelection.call( this, document.getSelection() );
		},

<span id='CKEDITOR-style-method-remove'>		/**
</span>		 * @param {CKEDITOR.dom.document} document
		 * @todo
		 */
		remove: function( document ) {
			applyStyleOnSelection.call( this, document.getSelection(), 1 );
		},

<span id='CKEDITOR-style-method-applyToRange'>		/**
</span>		 * @param {CKEDITOR.dom.range} range
		 * @todo
		 */
		applyToRange: function( range ) {
			return ( this.applyToRange =
			         this.type == CKEDITOR.STYLE_INLINE ? applyInlineStyle :
			         this.type == CKEDITOR.STYLE_BLOCK ? applyBlockStyle :
			         this.type == CKEDITOR.STYLE_OBJECT ? applyObjectStyle :
			         null ).call( this, range );
		},

<span id='CKEDITOR-style-method-removeFromRange'>		/**
</span>		 * @param {CKEDITOR.dom.range} range
		 * @todo
		 */
		removeFromRange: function( range ) {
			return ( this.removeFromRange =
			         this.type == CKEDITOR.STYLE_INLINE ? removeInlineStyle :
			         this.type == CKEDITOR.STYLE_BLOCK ? removeBlockStyle :
			         this.type == CKEDITOR.STYLE_OBJECT ? removeObjectStyle :
			         null ).call( this, range );
		},

<span id='CKEDITOR-style-method-applyToObject'>		/**
</span>		 * @param {CKEDITOR.dom.element} element
		 * @todo
		 */
		applyToObject: function( element ) {
			setupElement( element, this );
		},

<span id='CKEDITOR-style-method-checkActive'>		/**
</span>		 * Get the style state inside an element path.
		 *
		 * @param {CKEDITOR.dom.elementPath} elementPath
		 * @returns {Boolean} `true` if the element is active in the path.
		 */
		checkActive: function( elementPath ) {
			switch ( this.type ) {
				case CKEDITOR.STYLE_BLOCK:
					return this.checkElementRemovable( elementPath.block || elementPath.blockLimit, true );

				case CKEDITOR.STYLE_OBJECT:
				case CKEDITOR.STYLE_INLINE:

					var elements = elementPath.elements;

					for ( var i = 0, element; i &lt; elements.length; i++ ) {
						element = elements[ i ];

						if ( this.type == CKEDITOR.STYLE_INLINE &amp;&amp; ( element == elementPath.block || element == elementPath.blockLimit ) )
							continue;

						if ( this.type == CKEDITOR.STYLE_OBJECT ) {
							var name = element.getName();
							if ( !( typeof this.element == &#39;string&#39; ? name == this.element : name in this.element ) )
								continue;
						}

						if ( this.checkElementRemovable( element, true ) )
							return true;
					}
			}
			return false;
		},

<span id='CKEDITOR-style-method-checkApplicable'>		/**
</span>		 * Whether this style can be applied at the specified elements-path.
		 *
		 * @param {CKEDITOR.dom.elementPath} elementPath The elements-path to
		 * 	check the style against.
		 * @param {CKEDITOR.filter} [filter] If defined, the style will be
		 * 	checked against this filter as well.
		 * @returns {Boolean} `true` if this style can be applied at the element path.
		 */
		checkApplicable: function( elementPath, filter ) {
			if ( filter &amp;&amp; !filter.check( this ) )
				return false;

			switch ( this.type ) {
				case CKEDITOR.STYLE_OBJECT:
					return !!elementPath.contains( this.element );
				case CKEDITOR.STYLE_BLOCK:
					return !!elementPath.blockLimit.getDtd()[ this.element ];
			}

			return true;
		},

<span id='CKEDITOR-style-method-checkElementMatch'>		/**
</span>		 * Check if the element matches the current style definition.
		 *
		 * @param {CKEDITOR.dom.element} element
		 * @param {Boolean} fullMatch
		 * @returns {Boolean}
		 * @todo
		 */
		checkElementMatch: function( element, fullMatch ) {
			var def = this._.definition;

			if ( !element || !def.ignoreReadonly &amp;&amp; element.isReadOnly() )
				return false;

			var attribs,
				name = element.getName();

			// If the element name is the same as the style name.
			if ( typeof this.element == &#39;string&#39; ? name == this.element : name in this.element ) {
				// If no attributes are defined in the element.
				if ( !fullMatch &amp;&amp; !element.hasAttributes() )
					return true;

				attribs = getAttributesForComparison( def );

				if ( attribs._length ) {
					for ( var attName in attribs ) {
						if ( attName == &#39;_length&#39; )
							continue;

						var elementAttr = element.getAttribute( attName ) || &#39;&#39;;

						// Special treatment for &#39;style&#39; attribute is required.
						if ( attName == &#39;style&#39; ? compareCssText( attribs[ attName ], elementAttr ) : attribs[ attName ] == elementAttr ) {
							if ( !fullMatch )
								return true;
						} else if ( fullMatch )
							return false;
					}
					if ( fullMatch )
						return true;
				} else
					return true;
			}

			return false;
		},

<span id='CKEDITOR-style-method-checkElementRemovable'>		/**
</span>		 * Checks if an element, or any of its attributes, is removable by the
		 * current style definition.
		 *
		 * @param {CKEDITOR.dom.element} element
		 * @param {Boolean} fullMatch
		 * @returns {Boolean}
		 * @todo
		 */
		checkElementRemovable: function( element, fullMatch ) {
			// Check element matches the style itself.
			if ( this.checkElementMatch( element, fullMatch ) )
				return true;

			// Check if the element matches the style overrides.
			var override = getOverrides( this )[ element.getName() ];
			if ( override ) {
				var attribs, attName;

				// If no attributes have been defined, remove the element.
				if ( !( attribs = override.attributes ) )
					return true;

				for ( var i = 0; i &lt; attribs.length; i++ ) {
					attName = attribs[ i ][ 0 ];
					var actualAttrValue = element.getAttribute( attName );
					if ( actualAttrValue ) {
						var attValue = attribs[ i ][ 1 ];

						// Remove the attribute if:
						//    - The override definition value is null;
						//    - The override definition value is a string that
						//      matches the attribute value exactly.
						//    - The override definition value is a regex that
						//      has matches in the attribute value.
						if ( attValue === null || ( typeof attValue == &#39;string&#39; &amp;&amp; actualAttrValue == attValue ) || attValue.test( actualAttrValue ) )
							return true;
					}
				}
			}
			return false;
		},

<span id='CKEDITOR-style-method-buildPreview'>		/**
</span>		 * Builds the preview HTML based on the styles definition.
		 *
		 * @param label
		 * @todo
		 */
		buildPreview: function( label ) {
			var styleDefinition = this._.definition,
				html = [],
				elementName = styleDefinition.element;

			// Avoid &lt;bdo&gt; in the preview.
			if ( elementName == &#39;bdo&#39; )
				elementName = &#39;span&#39;;

			html = [ &#39;&lt;&#39;, elementName ];

			// Assign all defined attributes.
			var attribs = styleDefinition.attributes;
			if ( attribs ) {
				for ( var att in attribs )
					html.push( &#39; &#39;, att, &#39;=&quot;&#39;, attribs[ att ], &#39;&quot;&#39; );
			}

			// Assign the style attribute.
			var cssStyle = CKEDITOR.style.getStyleText( styleDefinition );
			if ( cssStyle )
				html.push( &#39; style=&quot;&#39;, cssStyle, &#39;&quot;&#39; );

			html.push( &#39;&gt;&#39;, ( label || styleDefinition.name ), &#39;&lt;/&#39;, elementName, &#39;&gt;&#39; );

			return html.join( &#39;&#39; );
		},

		getDefinition: function() {
			return this._.definition;
		}
	};

<span id='CKEDITOR-style-static-method-getStyleText'>	/**
</span>	 * Build the cssText based on the styles definition.
	 *
	 * @static
	 * @param styleDefinition
	 * @returns {String}
	 * @todo
	 */
	CKEDITOR.style.getStyleText = function( styleDefinition ) {
		// If we have already computed it, just return it.
		var stylesDef = styleDefinition._ST;
		if ( stylesDef )
			return stylesDef;

		stylesDef = styleDefinition.styles;

		// Builds the StyleText.
		var stylesText = ( styleDefinition.attributes &amp;&amp; styleDefinition.attributes[ &#39;style&#39; ] ) || &#39;&#39;,
			specialStylesText = &#39;&#39;;

		if ( stylesText.length )
			stylesText = stylesText.replace( semicolonFixRegex, &#39;;&#39; );

		for ( var style in stylesDef ) {
			var styleVal = stylesDef[ style ],
				text = ( style + &#39;:&#39; + styleVal ).replace( semicolonFixRegex, &#39;;&#39; );

			// Some browsers don&#39;t support &#39;inherit&#39; property value, leave them intact. (#5242)
			if ( styleVal == &#39;inherit&#39; )
				specialStylesText += text;
			else
				stylesText += text;
		}

		// Browsers make some changes to the style when applying them. So, here
		// we normalize it to the browser format.
		if ( stylesText.length )
			stylesText = CKEDITOR.tools.normalizeCssText( stylesText, true );

		stylesText += specialStylesText;

		// Return it, saving it to the next request.
		return ( styleDefinition._ST = stylesText );
	};

	// Gets the parent element which blocks the styling for an element. This
	// can be done through read-only elements (contenteditable=false) or
	// elements with the &quot;data-nostyle&quot; attribute.
	function getUnstylableParent( element, root ) {
		var unstylable, editable;

		while ( ( element = element.getParent() ) ) {
			if ( element.equals( root ) )
				break;

			if ( element.getAttribute( &#39;data-nostyle&#39; ) )
				unstylable = element;
			else if ( !editable ) {
				var contentEditable = element.getAttribute( &#39;contentEditable&#39; );

				if ( contentEditable == &#39;false&#39; )
					unstylable = element;
				else if ( contentEditable == &#39;true&#39; )
					editable = 1;
			}
		}

		return unstylable;
	}

	var posPrecedingIdenticalContained =
			CKEDITOR.POSITION_PRECEDING | CKEDITOR.POSITION_IDENTICAL | CKEDITOR.POSITION_IS_CONTAINED,
		posFollowingIdenticalContained =
			CKEDITOR.POSITION_FOLLOWING | CKEDITOR.POSITION_IDENTICAL | CKEDITOR.POSITION_IS_CONTAINED;

	// Checks if the current node can be a child of the style element.
	function checkIfNodeCanBeChildOfStyle( def, currentNode, lastNode, nodeName, dtd, nodeIsNoStyle, nodeIsReadonly, includeReadonly ) {
		// Style can be applied to text node.
		if ( !nodeName )
			return 1;

		// Style definitely cannot be applied if DTD or data-nostyle do not allow.
		if ( !dtd[ nodeName ] || nodeIsNoStyle  )
			return 0;

		// Non-editable element cannot be styled is we shouldn&#39;t include readonly elements.
		if ( nodeIsReadonly &amp;&amp; !includeReadonly  )
			return 0;

		// Check that we haven&#39;t passed lastNode yet and that style&#39;s childRule allows this style on current element.
		return checkPositionAndRule( currentNode, lastNode, def, posPrecedingIdenticalContained );
	}

	// Check if the style element can be a child of the current
	// node parent or if the element is not defined in the DTD.
	function checkIfStyleCanBeChildOf( def, currentParent, elementName, isUnknownElement ) {
		return currentParent &amp;&amp;
			( ( currentParent.getDtd() || CKEDITOR.dtd.span )[ elementName ] || isUnknownElement ) &amp;&amp;
			( !def.parentRule || def.parentRule( currentParent ) );
	}

	function checkIfStartsRange( nodeName, currentNode, lastNode ) {
		return (
			!nodeName || !CKEDITOR.dtd.$removeEmpty[ nodeName ] ||
			( currentNode.getPosition( lastNode ) | posPrecedingIdenticalContained ) == posPrecedingIdenticalContained
		);
	}

	function checkIfTextOrReadonlyOrEmptyElement( currentNode, nodeIsReadonly ) {
		var nodeType = currentNode.type;
		return nodeType == CKEDITOR.NODE_TEXT || nodeIsReadonly || ( nodeType == CKEDITOR.NODE_ELEMENT &amp;&amp; !currentNode.getChildCount() );
	}

	// Checks if position is a subset of posBitFlags and that nodeA fulfills style def rule.
	function checkPositionAndRule( nodeA, nodeB, def, posBitFlags ) {
		return ( nodeA.getPosition( nodeB ) | posBitFlags ) == posBitFlags &amp;&amp;
			( !def.childRule || def.childRule( nodeA ) );
	}

	function applyInlineStyle( range ) {
		var document = range.document;

		if ( range.collapsed ) {
			// Create the element to be inserted in the DOM.
			var collapsedElement = getElement( this, document );

			// Insert the empty element into the DOM at the range position.
			range.insertNode( collapsedElement );

			// Place the selection right inside the empty element.
			range.moveToPosition( collapsedElement, CKEDITOR.POSITION_BEFORE_END );

			return;
		}

		var elementName = this.element,
			def = this._.definition,
			isUnknownElement;

		// Indicates that fully selected read-only elements are to be included in the styling range.
		var ignoreReadonly = def.ignoreReadonly,
			includeReadonly = ignoreReadonly || def.includeReadonly;

		// If the read-only inclusion is not available in the definition, try
		// to get it from the root data (most often it&#39;s the editable).
		if ( includeReadonly == undefined )
			includeReadonly = range.root.getCustomData( &#39;cke_includeReadonly&#39; );

		// Get the DTD definition for the element. Defaults to &quot;span&quot;.
		var dtd = CKEDITOR.dtd[ elementName ];
		if ( !dtd ) {
			isUnknownElement = true;
			dtd = CKEDITOR.dtd.span;
		}

		// Expand the range.
		range.enlarge( CKEDITOR.ENLARGE_INLINE, 1 );
		range.trim();

		// Get the first node to be processed and the last, which concludes the processing.
		var boundaryNodes = range.createBookmark(),
			firstNode = boundaryNodes.startNode,
			lastNode = boundaryNodes.endNode,
			currentNode = firstNode,
			styleRange;

		if ( !ignoreReadonly ) {
			// Check if the boundaries are inside non stylable elements.
			var root = range.getCommonAncestor(),
				firstUnstylable = getUnstylableParent( firstNode, root ),
				lastUnstylable = getUnstylableParent( lastNode, root );

			// If the first element can&#39;t be styled, we&#39;ll start processing right
			// after its unstylable root.
			if ( firstUnstylable )
				currentNode = firstUnstylable.getNextSourceNode( true );

			// If the last element can&#39;t be styled, we&#39;ll stop processing on its
			// unstylable root.
			if ( lastUnstylable )
				lastNode = lastUnstylable;
		}

		// Do nothing if the current node now follows the last node to be processed.
		if ( currentNode.getPosition( lastNode ) == CKEDITOR.POSITION_FOLLOWING )
			currentNode = 0;

		while ( currentNode ) {
			var applyStyle = false;

			if ( currentNode.equals( lastNode ) ) {
				currentNode = null;
				applyStyle = true;
			} else {
				var nodeName = currentNode.type == CKEDITOR.NODE_ELEMENT ? currentNode.getName() : null,
					nodeIsReadonly = nodeName &amp;&amp; ( currentNode.getAttribute( &#39;contentEditable&#39; ) == &#39;false&#39; ),
					nodeIsNoStyle = nodeName &amp;&amp; currentNode.getAttribute( &#39;data-nostyle&#39; );

				// Skip bookmarks.
				if ( nodeName &amp;&amp; currentNode.data( &#39;cke-bookmark&#39; ) ) {
					currentNode = currentNode.getNextSourceNode( true );
					continue;
				}

				// Find all nested editables of a non-editable block and apply this style inside them.
				if ( nodeIsReadonly &amp;&amp; includeReadonly &amp;&amp; CKEDITOR.dtd.$block[ nodeName ] )
					applyStyleOnNestedEditables.call( this, currentNode );

				// Check if the current node can be a child of the style element.
				if ( checkIfNodeCanBeChildOfStyle( def, currentNode, lastNode, nodeName, dtd, nodeIsNoStyle, nodeIsReadonly, includeReadonly ) ) {
					var currentParent = currentNode.getParent();

					// Check if the style element can be a child of the current
					// node parent or if the element is not defined in the DTD.
					if ( checkIfStyleCanBeChildOf( def, currentParent, elementName, isUnknownElement ) ) {
						// This node will be part of our range, so if it has not
						// been started, place its start right before the node.
						// In the case of an element node, it will be included
						// only if it is entirely inside the range.
						if ( !styleRange &amp;&amp; checkIfStartsRange( nodeName, currentNode, lastNode ) ) {
							styleRange = range.clone();
							styleRange.setStartBefore( currentNode );
						}

						// Non element nodes, readonly elements, or empty
						// elements can be added completely to the range.
						if ( checkIfTextOrReadonlyOrEmptyElement( currentNode, nodeIsReadonly ) ) {
							var includedNode = currentNode;
							var parentNode;

							// This node is about to be included completelly, but,
							// if this is the last node in its parent, we must also
							// check if the parent itself can be added completelly
							// to the range, otherwise apply the style immediately.
							while (
								( applyStyle = !includedNode.getNext( notBookmark ) ) &amp;&amp;
								( parentNode = includedNode.getParent(), dtd[ parentNode.getName() ] ) &amp;&amp;
								checkPositionAndRule( parentNode, firstNode, def, posFollowingIdenticalContained )
							) {
								includedNode = parentNode;
							}

							styleRange.setEndAfter( includedNode );

						}
					} else
						applyStyle = true;
				}
				// Style isn&#39;t applicable to current element, so apply style to
				// range ending at previously chosen position, or nowhere if we haven&#39;t
				// yet started styleRange.
				else
					applyStyle = true;

				// Get the next node to be processed.
				// If we&#39;re currently on a non-editable element or non-styleable element,
				// then we&#39;ll be moved to current node&#39;s sibling (or even further), so we&#39;ll
				// avoid messing up its content.
				currentNode = currentNode.getNextSourceNode( nodeIsNoStyle || nodeIsReadonly );
			}

			// Apply the style if we have something to which apply it.
			if ( applyStyle &amp;&amp; styleRange &amp;&amp; !styleRange.collapsed ) {
				// Build the style element, based on the style object definition.
				var styleNode = getElement( this, document ),
					styleHasAttrs = styleNode.hasAttributes();

				// Get the element that holds the entire range.
				var parent = styleRange.getCommonAncestor();

				var removeList = {
					styles: {},
					attrs: {},
					// Styles cannot be removed.
					blockedStyles: {},
					// Attrs cannot be removed.
					blockedAttrs: {}
				};

				var attName, styleName, value;

				// Loop through the parents, removing the redundant attributes
				// from the element to be applied.
				while ( styleNode &amp;&amp; parent ) {
					if ( parent.getName() == elementName ) {
						for ( attName in def.attributes ) {
							if ( removeList.blockedAttrs[ attName ] || !( value = parent.getAttribute( styleName ) ) )
								continue;

							if ( styleNode.getAttribute( attName ) == value )
								removeList.attrs[ attName ] = 1;
							else
								removeList.blockedAttrs[ attName ] = 1;
						}

						for ( styleName in def.styles ) {
							if ( removeList.blockedStyles[ styleName ] || !( value = parent.getStyle( styleName ) ) )
								continue;

							if ( styleNode.getStyle( styleName ) == value )
								removeList.styles[ styleName ] = 1;
							else
								removeList.blockedStyles[ styleName ] = 1;
						}
					}

					parent = parent.getParent();
				}

				for ( attName in removeList.attrs )
					styleNode.removeAttribute( attName );

				for ( styleName in removeList.styles )
					styleNode.removeStyle( styleName );

				if ( styleHasAttrs &amp;&amp; !styleNode.hasAttributes() )
					styleNode = null;

				if ( styleNode ) {
					// Move the contents of the range to the style element.
					styleRange.extractContents().appendTo( styleNode );

					// Insert it into the range position (it is collapsed after
					// extractContents.
					styleRange.insertNode( styleNode );

					// Here we do some cleanup, removing all duplicated
					// elements from the style element.
					removeFromInsideElement.call( this, styleNode );

					// Let&#39;s merge our new style with its neighbors, if possible.
					styleNode.mergeSiblings();

					// As the style system breaks text nodes constantly, let&#39;s normalize
					// things for performance.
					// With IE, some paragraphs get broken when calling normalize()
					// repeatedly. Also, for IE, we must normalize body, not documentElement.
					// IE is also known for having a &quot;crash effect&quot; with normalize().
					// We should try to normalize with IE too in some way, somewhere.
					if ( !CKEDITOR.env.ie )
						styleNode.$.normalize();
				}
				// Style already inherit from parents, left just to clear up any internal overrides. (#5931)
				else {
					styleNode = new CKEDITOR.dom.element( &#39;span&#39; );
					styleRange.extractContents().appendTo( styleNode );
					styleRange.insertNode( styleNode );
					removeFromInsideElement.call( this, styleNode );
					styleNode.remove( true );
				}

				// Style applied, let&#39;s release the range, so it gets
				// re-initialization in the next loop.
				styleRange = null;
			}
		}

		// Remove the bookmark nodes.
		range.moveToBookmark( boundaryNodes );

		// Minimize the result range to exclude empty text nodes. (#5374)
		range.shrink( CKEDITOR.SHRINK_TEXT );

		// Get inside the remaining element if range.shrink( TEXT ) has failed because of non-editable elements inside.
		// E.g. range.shrink( TEXT ) will not get inside:
		// [&lt;b&gt;&lt;i contenteditable=&quot;false&quot;&gt;x&lt;/i&gt;&lt;/b&gt;]
		// but range.shrink( ELEMENT ) will.
		range.shrink( CKEDITOR.NODE_ELEMENT, true );
	}

	function removeInlineStyle( range ) {
		// Make sure our range has included all &quot;collpased&quot; parent inline nodes so
		// that our operation logic can be simpler.
		range.enlarge( CKEDITOR.ENLARGE_INLINE, 1 );

		var bookmark = range.createBookmark(),
			startNode = bookmark.startNode;

		if ( range.collapsed ) {
			var startPath = new CKEDITOR.dom.elementPath( startNode.getParent(), range.root ),
				// The topmost element in elementspatch which we should jump out of.
				boundaryElement;


			for ( var i = 0, element; i &lt; startPath.elements.length &amp;&amp; ( element = startPath.elements[ i ] ); i++ ) {
				// 1. If it&#39;s collaped inside text nodes, try to remove the style from the whole element.
				//
				// 2. Otherwise if it&#39;s collapsed on element boundaries, moving the selection
				//  outside the styles instead of removing the whole tag,
				//  also make sure other inner styles were well preserverd.(#3309)
				if ( element == startPath.block || element == startPath.blockLimit )
					break;

				if ( this.checkElementRemovable( element ) ) {
					var isStart;

					if ( range.collapsed &amp;&amp; ( range.checkBoundaryOfElement( element, CKEDITOR.END ) || ( isStart = range.checkBoundaryOfElement( element, CKEDITOR.START ) ) ) ) {
						boundaryElement = element;
						boundaryElement.match = isStart ? &#39;start&#39; : &#39;end&#39;;
					} else {
						// Before removing the style node, there may be a sibling to the style node
						// that&#39;s exactly the same to the one to be removed. To the user, it makes
						// no difference that they&#39;re separate entities in the DOM tree. So, merge
						// them before removal.
						element.mergeSiblings();
						if ( element.is( this.element ) )
							removeFromElement.call( this, element );
						else
							removeOverrides( element, getOverrides( this )[ element.getName() ] );
					}
				}
			}

			// Re-create the style tree after/before the boundary element,
			// the replication start from bookmark start node to define the
			// new range.
			if ( boundaryElement ) {
				var clonedElement = startNode;
				for ( i = 0; ; i++ ) {
					var newElement = startPath.elements[ i ];
					if ( newElement.equals( boundaryElement ) )
						break;
					// Avoid copying any matched element.
					else if ( newElement.match )
						continue;
					else
						newElement = newElement.clone();
					newElement.append( clonedElement );
					clonedElement = newElement;
				}
				clonedElement[ boundaryElement.match == &#39;start&#39; ? &#39;insertBefore&#39; : &#39;insertAfter&#39; ]( boundaryElement );
			}
		} else {
			// Now our range isn&#39;t collapsed. Lets walk from the start node to the end
			// node via DFS and remove the styles one-by-one.
			var endNode = bookmark.endNode,
				me = this;

			breakNodes();

			// Now, do the DFS walk.
			var currentNode = startNode;
			while ( !currentNode.equals( endNode ) ) {
				// Need to get the next node first because removeFromElement() can remove
				// the current node from DOM tree.
				var nextNode = currentNode.getNextSourceNode();
				if ( currentNode.type == CKEDITOR.NODE_ELEMENT &amp;&amp; this.checkElementRemovable( currentNode ) ) {
					// Remove style from element or overriding element.
					if ( currentNode.getName() == this.element )
						removeFromElement.call( this, currentNode );
					else
						removeOverrides( currentNode, getOverrides( this )[ currentNode.getName() ] );

					// removeFromElement() may have merged the next node with something before
					// the startNode via mergeSiblings(). In that case, the nextNode would
					// contain startNode and we&#39;ll have to call breakNodes() again and also
					// reassign the nextNode to something after startNode.
					if ( nextNode.type == CKEDITOR.NODE_ELEMENT &amp;&amp; nextNode.contains( startNode ) ) {
						breakNodes();
						nextNode = startNode.getNext();
					}
				}
				currentNode = nextNode;
			}
		}

		range.moveToBookmark( bookmark );
		// See the comment for range.shrink in applyInlineStyle.
		range.shrink( CKEDITOR.NODE_ELEMENT, true );

		// Find out the style ancestor that needs to be broken down at startNode
		// and endNode.
		function breakNodes() {
			var startPath = new CKEDITOR.dom.elementPath( startNode.getParent() ),
				endPath = new CKEDITOR.dom.elementPath( endNode.getParent() ),
				breakStart = null,
				breakEnd = null;

			for ( var i = 0; i &lt; startPath.elements.length; i++ ) {
				var element = startPath.elements[ i ];

				if ( element == startPath.block || element == startPath.blockLimit )
					break;

				if ( me.checkElementRemovable( element ) )
					breakStart = element;
			}

			for ( i = 0; i &lt; endPath.elements.length; i++ ) {
				element = endPath.elements[ i ];

				if ( element == endPath.block || element == endPath.blockLimit )
					break;

				if ( me.checkElementRemovable( element ) )
					breakEnd = element;
			}

			if ( breakEnd )
				endNode.breakParent( breakEnd );
			if ( breakStart )
				startNode.breakParent( breakStart );
		}
	}

	// Apply style to nested editables inside editablesContainer.
	// @param {CKEDITOR.dom.element} editablesContainer
	// @context CKEDITOR.style
	function applyStyleOnNestedEditables( editablesContainer ) {
		var editables = findNestedEditables( editablesContainer ),
			editable,
			l = editables.length,
			i = 0,
			range = l &amp;&amp; new CKEDITOR.dom.range( editablesContainer.getDocument() );

		for ( ; i &lt; l; ++i ) {
			editable = editables[ i ];
			// Check if style is allowed by this editable&#39;s ACF.
			if ( checkIfAllowedInEditable( editable, this ) ) {
				range.selectNodeContents( editable );
				applyInlineStyle.call( this, range );
			}
		}
	}

	// Finds nested editables within container. Does not return
	// editables nested in another editable (twice).
	function findNestedEditables( container ) {
		var editables = [];

		container.forEach( function( element ) {
			if ( element.getAttribute( &#39;contenteditable&#39; ) == &#39;true&#39; ) {
				editables.push( element );
				return false; // Skip children.
			}
		}, CKEDITOR.NODE_ELEMENT, true );

		return editables;
	}

	// Checks if style is allowed in this editable.
	function checkIfAllowedInEditable( editable, style ) {
		var filter = CKEDITOR.filter.instances[ editable.data( &#39;cke-filter&#39; ) ];

		return filter ? filter.check( style ) : 1;
	}

	// Checks if style is allowed by iterator&#39;s active filter.
	function checkIfAllowedByIterator( iterator, style ) {
		return iterator.activeFilter ? iterator.activeFilter.check( style ) : 1;
	}

	function applyObjectStyle( range ) {
		// Selected or parent element. (#9651)
		var start = range.getEnclosedNode() || range.getCommonAncestor( false, true ),
			element = new CKEDITOR.dom.elementPath( start, range.root ).contains( this.element, 1 );

		element &amp;&amp; !element.isReadOnly() &amp;&amp; setupElement( element, this );
	}

	function removeObjectStyle( range ) {
		var parent = range.getCommonAncestor( true, true ),
			element = new CKEDITOR.dom.elementPath( parent, range.root ).contains( this.element, 1 );

		if ( !element )
			return;

		var style = this,
			def = style._.definition,
			attributes = def.attributes;

		// Remove all defined attributes.
		if ( attributes ) {
			for ( var att in attributes )
				element.removeAttribute( att, attributes[ att ] );
		}

		// Assign all defined styles.
		if ( def.styles ) {
			for ( var i in def.styles ) {
				if ( def.styles.hasOwnProperty( i ) )
					element.removeStyle( i );
			}
		}
	}

	function applyBlockStyle( range ) {
		// Serializible bookmarks is needed here since
		// elements may be merged.
		var bookmark = range.createBookmark( true );

		var iterator = range.createIterator();
		iterator.enforceRealBlocks = true;

		// make recognize &lt;br /&gt; tag as a separator in ENTER_BR mode (#5121)
		if ( this._.enterMode )
			iterator.enlargeBr = ( this._.enterMode != CKEDITOR.ENTER_BR );

		var block,
			doc = range.document,
			previousPreBlock,
			newBlock;

		while ( ( block = iterator.getNextParagraph() ) ) {
			if ( !block.isReadOnly() &amp;&amp; checkIfAllowedByIterator( iterator, this ) ) {
				newBlock = getElement( this, doc, block );
				replaceBlock( block, newBlock );
			}
		}

		range.moveToBookmark( bookmark );
	}

	function removeBlockStyle( range ) {
		// Serializible bookmarks is needed here since
		// elements may be merged.
		var bookmark = range.createBookmark( 1 );

		var iterator = range.createIterator();
		iterator.enforceRealBlocks = true;
		iterator.enlargeBr = this._.enterMode != CKEDITOR.ENTER_BR;

		var block,
			newBlock;

		while ( ( block = iterator.getNextParagraph() ) ) {
			if ( this.checkElementRemovable( block ) ) {
				// &lt;pre&gt; get special treatment.
				if ( block.is( &#39;pre&#39; ) ) {
					newBlock = this._.enterMode == CKEDITOR.ENTER_BR ? null :
							range.document.createElement( this._.enterMode == CKEDITOR.ENTER_P ? &#39;p&#39; : &#39;div&#39; );

					newBlock &amp;&amp; block.copyAttributes( newBlock );
					replaceBlock( block, newBlock );
				} else
					removeFromElement.call( this, block );
			}
		}

		range.moveToBookmark( bookmark );
	}

	// Replace the original block with new one, with special treatment
	// for &lt;pre&gt; blocks to make sure content format is well preserved, and merging/splitting adjacent
	// when necessary. (#3188)
	function replaceBlock( block, newBlock ) {
		// Block is to be removed, create a temp element to
		// save contents.
		var removeBlock = !newBlock;
		if ( removeBlock ) {
			newBlock = block.getDocument().createElement( &#39;div&#39; );
			block.copyAttributes( newBlock );
		}

		var newBlockIsPre = newBlock &amp;&amp; newBlock.is( &#39;pre&#39; ),
			blockIsPre = block.is( &#39;pre&#39; ),
			isToPre = newBlockIsPre &amp;&amp; !blockIsPre,
			isFromPre = !newBlockIsPre &amp;&amp; blockIsPre;

		if ( isToPre )
			newBlock = toPre( block, newBlock );
		else if ( isFromPre )
			// Split big &lt;pre&gt; into pieces before start to convert.
			newBlock = fromPres( removeBlock ? [ block.getHtml() ] : splitIntoPres( block ), newBlock );
		else
			block.moveChildren( newBlock );

		newBlock.replace( block );

		if ( newBlockIsPre ) {
			// Merge previous &lt;pre&gt; blocks.
			mergePre( newBlock );
		} else if ( removeBlock )
			removeNoAttribsElement( newBlock );
	}

	// Merge a &lt;pre&gt; block with a previous sibling if available.
	function mergePre( preBlock ) {
		var previousBlock;
		if ( !( ( previousBlock = preBlock.getPrevious( nonWhitespaces ) ) &amp;&amp; previousBlock.type == CKEDITOR.NODE_ELEMENT &amp;&amp; previousBlock.is( &#39;pre&#39; ) ) )
			return;

		// Merge the previous &lt;pre&gt; block contents into the current &lt;pre&gt;
		// block.
		//
		// Another thing to be careful here is that currentBlock might contain
		// a &#39;\n&#39; at the beginning, and previousBlock might contain a &#39;\n&#39;
		// towards the end. These new lines are not normally displayed but they
		// become visible after merging.
		var mergedHtml = replace( previousBlock.getHtml(), /\n$/, &#39;&#39; ) + &#39;\n\n&#39; +
			replace( preBlock.getHtml(), /^\n/, &#39;&#39; );

		// Krugle: IE normalizes innerHTML from &lt;pre&gt;, breaking whitespaces.
		if ( CKEDITOR.env.ie )
			preBlock.$.outerHTML = &#39;&lt;pre&gt;&#39; + mergedHtml + &#39;&lt;/pre&gt;&#39;;
		else
			preBlock.setHtml( mergedHtml );

		previousBlock.remove();
	}

	// Split into multiple &lt;pre&gt; blocks separated by double line-break.
	function splitIntoPres( preBlock ) {
		// Exclude the ones at header OR at tail,
		// and ignore bookmark content between them.
		var duoBrRegex = /(\S\s*)\n(?:\s|(&lt;span[^&gt;]+data-cke-bookmark.*?\/span&gt;))*\n(?!$)/gi,
			blockName = preBlock.getName(),
			pres = [],
			splitedHtml = replace( preBlock.getOuterHtml(), duoBrRegex, function( match, charBefore, bookmark ) {
				return charBefore + &#39;&lt;/pre&gt;&#39; + bookmark + &#39;&lt;pre&gt;&#39;;
			} );

		splitedHtml.replace( /&lt;pre\b.*?&gt;([\s\S]*?)&lt;\/pre&gt;/gi, function( match, preContent ) {
			pres.push( preContent );
		} );
		return pres;
	}

	// Wrapper function of String::replace without considering of head/tail bookmarks nodes.
	function replace( str, regexp, replacement ) {
		var headBookmark = &#39;&#39;,
			tailBookmark = &#39;&#39;;

		str = str.replace( /(^&lt;span[^&gt;]+data-cke-bookmark.*?\/span&gt;)|(&lt;span[^&gt;]+data-cke-bookmark.*?\/span&gt;$)/gi, function( str, m1, m2 ) {
			m1 &amp;&amp; ( headBookmark = m1 );
			m2 &amp;&amp; ( tailBookmark = m2 );
			return &#39;&#39;;
		} );
		return headBookmark + str.replace( regexp, replacement ) + tailBookmark;
	}

	// Converting a list of &lt;pre&gt; into blocks with format well preserved.
	function fromPres( preHtmls, newBlock ) {
		var docFrag;
		if ( preHtmls.length &gt; 1 )
			docFrag = new CKEDITOR.dom.documentFragment( newBlock.getDocument() );

		for ( var i = 0; i &lt; preHtmls.length; i++ ) {
			var blockHtml = preHtmls[ i ];

			// 1. Trim the first and last line-breaks immediately after and before &lt;pre&gt;,
			// they&#39;re not visible.
			blockHtml = blockHtml.replace( /(\r\n|\r)/g, &#39;\n&#39; );
			blockHtml = replace( blockHtml, /^[ \t]*\n/, &#39;&#39; );
			blockHtml = replace( blockHtml, /\n$/, &#39;&#39; );
			// 2. Convert spaces or tabs at the beginning or at the end to &amp;nbsp;
			blockHtml = replace( blockHtml, /^[ \t]+|[ \t]+$/g, function( match, offset, s ) {
				if ( match.length == 1 ) // one space, preserve it
					return &#39;&amp;nbsp;&#39;;
				else if ( !offset ) // beginning of block
					return CKEDITOR.tools.repeat( &#39;&amp;nbsp;&#39;, match.length - 1 ) + &#39; &#39;;
				else // end of block
					return &#39; &#39; + CKEDITOR.tools.repeat( &#39;&amp;nbsp;&#39;, match.length - 1 );
			} );

			// 3. Convert \n to &lt;BR&gt;.
			// 4. Convert contiguous (i.e. non-singular) spaces or tabs to &amp;nbsp;
			blockHtml = blockHtml.replace( /\n/g, &#39;&lt;br&gt;&#39; );
			blockHtml = blockHtml.replace( /[ \t]{2,}/g, function( match ) {
				return CKEDITOR.tools.repeat( &#39;&amp;nbsp;&#39;, match.length - 1 ) + &#39; &#39;;
			} );

			if ( docFrag ) {
				var newBlockClone = newBlock.clone();
				newBlockClone.setHtml( blockHtml );
				docFrag.append( newBlockClone );
			} else
				newBlock.setHtml( blockHtml );
		}

		return docFrag || newBlock;
	}

	// Converting from a non-PRE block to a PRE block in formatting operations.
	function toPre( block, newBlock ) {
		var bogus = block.getBogus();
		bogus &amp;&amp; bogus.remove();

		// First trim the block content.
		var preHtml = block.getHtml();

		// 1. Trim head/tail spaces, they&#39;re not visible.
		preHtml = replace( preHtml, /(?:^[ \t\n\r]+)|(?:[ \t\n\r]+$)/g, &#39;&#39; );
		// 2. Delete ANSI whitespaces immediately before and after &lt;BR&gt; because
		//    they are not visible.
		preHtml = preHtml.replace( /[ \t\r\n]*(&lt;br[^&gt;]*&gt;)[ \t\r\n]*/gi, &#39;$1&#39; );
		// 3. Compress other ANSI whitespaces since they&#39;re only visible as one
		//    single space previously.
		// 4. Convert &amp;nbsp; to spaces since &amp;nbsp; is no longer needed in &lt;PRE&gt;.
		preHtml = preHtml.replace( /([ \t\n\r]+|&amp;nbsp;)/g, &#39; &#39; );
		// 5. Convert any &lt;BR /&gt; to \n. This must not be done earlier because
		//    the \n would then get compressed.
		preHtml = preHtml.replace( /&lt;br\b[^&gt;]*&gt;/gi, &#39;\n&#39; );

		// Krugle: IE normalizes innerHTML to &lt;pre&gt;, breaking whitespaces.
		if ( CKEDITOR.env.ie ) {
			var temp = block.getDocument().createElement( &#39;div&#39; );
			temp.append( newBlock );
			newBlock.$.outerHTML = &#39;&lt;pre&gt;&#39; + preHtml + &#39;&lt;/pre&gt;&#39;;
			newBlock.copyAttributes( temp.getFirst() );
			newBlock = temp.getFirst().remove();
		} else
			newBlock.setHtml( preHtml );

		return newBlock;
	}

	// Removes a style from an element itself, don&#39;t care about its subtree.
	function removeFromElement( element, keepDataAttrs ) {
		var def = this._.definition,
			attributes = def.attributes,
			styles = def.styles,
			overrides = getOverrides( this )[ element.getName() ],
			// If the style is only about the element itself, we have to remove the element.
			removeEmpty = CKEDITOR.tools.isEmpty( attributes ) &amp;&amp; CKEDITOR.tools.isEmpty( styles );

		// Remove definition attributes/style from the elemnt.
		for ( var attName in attributes ) {
			// The &#39;class&#39; element value must match (#1318).
			if ( ( attName == &#39;class&#39; || this._.definition.fullMatch ) &amp;&amp; element.getAttribute( attName ) != normalizeProperty( attName, attributes[ attName ] ) )
				continue;

			// Do not touch data-* attributes (#11011) (#11258).
			if ( keepDataAttrs &amp;&amp; attName.slice( 0, 5 ) == &#39;data-&#39; )
				continue;

			removeEmpty = element.hasAttribute( attName );
			element.removeAttribute( attName );
		}

		for ( var styleName in styles ) {
			// Full match style insist on having fully equivalence. (#5018)
			if ( this._.definition.fullMatch &amp;&amp; element.getStyle( styleName ) != normalizeProperty( styleName, styles[ styleName ], true ) )
				continue;

			removeEmpty = removeEmpty || !!element.getStyle( styleName );
			element.removeStyle( styleName );
		}

		// Remove overrides, but don&#39;t remove the element if it&#39;s a block element
		removeOverrides( element, overrides, blockElements[ element.getName() ] );

		if ( removeEmpty ) {
			if ( this._.definition.alwaysRemoveElement )
				removeNoAttribsElement( element, 1 );
			else {
				if ( !CKEDITOR.dtd.$block[ element.getName() ] || this._.enterMode == CKEDITOR.ENTER_BR &amp;&amp; !element.hasAttributes() )
					removeNoAttribsElement( element );
				else
					element.renameNode( this._.enterMode == CKEDITOR.ENTER_P ? &#39;p&#39; : &#39;div&#39; );
			}
		}
	}

	// Removes a style from inside an element. Called on applyStyle to make cleanup
	// before apply. During clean up this function keep data-* attribute in contrast
	// to removeFromElement.
	function removeFromInsideElement( element ) {
		var def = this._.definition,
			attribs = def.attributes,
			styles = def.styles,
			overrides = getOverrides( this ),
			innerElements = element.getElementsByTag( this.element ),
			innerElement;

		for ( var i = innerElements.count(); --i &gt;= 0; ) {
			innerElement = innerElements.getItem( i );

			// Do not remove elements which are read only (e.g. duplicates inside widgets).
			if ( !innerElement.isReadOnly() )
				removeFromElement.call( this, innerElement, true );
		}

		// Now remove any other element with different name that is
		// defined to be overriden.
		for ( var overrideElement in overrides ) {
			if ( overrideElement != this.element ) {
				innerElements = element.getElementsByTag( overrideElement );

				for ( i = innerElements.count() - 1; i &gt;= 0; i-- ) {
					innerElement = innerElements.getItem( i );

					// Do not remove elements which are read only (e.g. duplicates inside widgets).
					if ( !innerElement.isReadOnly() )
						removeOverrides( innerElement, overrides[ overrideElement ] );
				}
			}
		}
	}

	// Remove overriding styles/attributes from the specific element.
	// Note: Remove the element if no attributes remain.
	// @param {Object} element
	// @param {Object} overrides
	// @param {Boolean} Don&#39;t remove the element
	function removeOverrides( element, overrides, dontRemove ) {
		var attributes = overrides &amp;&amp; overrides.attributes;

		if ( attributes ) {
			for ( var i = 0; i &lt; attributes.length; i++ ) {
				var attName = attributes[ i ][ 0 ],
					actualAttrValue;

				if ( ( actualAttrValue = element.getAttribute( attName ) ) ) {
					var attValue = attributes[ i ][ 1 ];

					// Remove the attribute if:
					//    - The override definition value is null ;
					//    - The override definition valie is a string that
					//      matches the attribute value exactly.
					//    - The override definition value is a regex that
					//      has matches in the attribute value.
					if ( attValue === null || ( attValue.test &amp;&amp; attValue.test( actualAttrValue ) ) || ( typeof attValue == &#39;string&#39; &amp;&amp; actualAttrValue == attValue ) )
						element.removeAttribute( attName );
				}
			}
		}

		if ( !dontRemove )
			removeNoAttribsElement( element );
	}

	// If the element has no more attributes, remove it.
	function removeNoAttribsElement( element, forceRemove ) {
		// If no more attributes remained in the element, remove it,
		// leaving its children.
		if ( !element.hasAttributes() || forceRemove ) {
			if ( CKEDITOR.dtd.$block[ element.getName() ] ) {
				var previous = element.getPrevious( nonWhitespaces ),
					next = element.getNext( nonWhitespaces );

				if ( previous &amp;&amp; ( previous.type == CKEDITOR.NODE_TEXT || !previous.isBlockBoundary( { br: 1 } ) ) )
					element.append( &#39;br&#39;, 1 );
				if ( next &amp;&amp; ( next.type == CKEDITOR.NODE_TEXT || !next.isBlockBoundary( { br: 1 } ) ) )
					element.append( &#39;br&#39; );

				element.remove( true );
			} else {
				// Removing elements may open points where merging is possible,
				// so let&#39;s cache the first and last nodes for later checking.
				var firstChild = element.getFirst();
				var lastChild = element.getLast();

				element.remove( true );

				if ( firstChild ) {
					// Check the cached nodes for merging.
					firstChild.type == CKEDITOR.NODE_ELEMENT &amp;&amp; firstChild.mergeSiblings();

					if ( lastChild &amp;&amp; !firstChild.equals( lastChild ) &amp;&amp; lastChild.type == CKEDITOR.NODE_ELEMENT )
						lastChild.mergeSiblings();
				}

			}
		}
	}

	function getElement( style, targetDocument, element ) {
		var el,
			def = style._.definition,
			elementName = style.element;

		// The &quot;*&quot; element name will always be a span for this function.
		if ( elementName == &#39;*&#39; )
			elementName = &#39;span&#39;;

		// Create the element.
		el = new CKEDITOR.dom.element( elementName, targetDocument );

		// #6226: attributes should be copied before the new ones are applied
		if ( element )
			element.copyAttributes( el );

		el = setupElement( el, style );

		// Avoid ID duplication.
		if ( targetDocument.getCustomData( &#39;doc_processing_style&#39; ) &amp;&amp; el.hasAttribute( &#39;id&#39; ) )
			el.removeAttribute( &#39;id&#39; );
		else
			targetDocument.setCustomData( &#39;doc_processing_style&#39;, 1 );

		return el;
	}

	function setupElement( el, style ) {
		var def = style._.definition,
			attributes = def.attributes,
			styles = CKEDITOR.style.getStyleText( def );

		// Assign all defined attributes.
		if ( attributes ) {
			for ( var att in attributes )
				el.setAttribute( att, attributes[ att ] );
		}

		// Assign all defined styles.
		if ( styles )
			el.setAttribute( &#39;style&#39;, styles );

		return el;
	}

	function replaceVariables( list, variablesValues ) {
		for ( var item in list ) {
			list[ item ] = list[ item ].replace( varRegex, function( match, varName ) {
				return variablesValues[ varName ];
			} );
		}
	}

	// Returns an object that can be used for style matching comparison.
	// Attributes names and values are all lowercased, and the styles get
	// merged with the style attribute.
	function getAttributesForComparison( styleDefinition ) {
		// If we have already computed it, just return it.
		var attribs = styleDefinition._AC;
		if ( attribs )
			return attribs;

		attribs = {};

		var length = 0;

		// Loop through all defined attributes.
		var styleAttribs = styleDefinition.attributes;
		if ( styleAttribs ) {
			for ( var styleAtt in styleAttribs ) {
				length++;
				attribs[ styleAtt ] = styleAttribs[ styleAtt ];
			}
		}

		// Includes the style definitions.
		var styleText = CKEDITOR.style.getStyleText( styleDefinition );
		if ( styleText ) {
			if ( !attribs[ &#39;style&#39; ] )
				length++;
			attribs[ &#39;style&#39; ] = styleText;
		}

		// Appends the &quot;length&quot; information to the object.
		attribs._length = length;

		// Return it, saving it to the next request.
		return ( styleDefinition._AC = attribs );
	}

	// Get the the collection used to compare the elements and attributes,
	// defined in this style overrides, with other element. All information in
	// it is lowercased.
	// @param {CKEDITOR.style} style
	function getOverrides( style ) {
		if ( style._.overrides )
			return style._.overrides;

		var overrides = ( style._.overrides = {} ),
			definition = style._.definition.overrides;

		if ( definition ) {
			// The override description can be a string, object or array.
			// Internally, well handle arrays only, so transform it if needed.
			if ( !CKEDITOR.tools.isArray( definition ) )
				definition = [ definition ];

			// Loop through all override definitions.
			for ( var i = 0; i &lt; definition.length; i++ ) {
				var override = definition[ i ],
					elementName,
					overrideEl,
					attrs;

				// If can be a string with the element name.
				if ( typeof override == &#39;string&#39; )
					elementName = override.toLowerCase();
				// Or an object.
				else {
					elementName = override.element ? override.element.toLowerCase() : style.element;
					attrs = override.attributes;
				}

				// We can have more than one override definition for the same
				// element name, so we attempt to simply append information to
				// it if it already exists.
				overrideEl = overrides[ elementName ] || ( overrides[ elementName ] = {} );

				if ( attrs ) {
					// The returning attributes list is an array, because we
					// could have different override definitions for the same
					// attribute name.
					var overrideAttrs = ( overrideEl.attributes = overrideEl.attributes || new Array() );
					for ( var attName in attrs ) {
						// Each item in the attributes array is also an array,
						// where [0] is the attribute name and [1] is the
						// override value.
						overrideAttrs.push( [ attName.toLowerCase(), attrs[ attName ] ] );
					}
				}
			}
		}

		return overrides;
	}

	// Make the comparison of attribute value easier by standardizing it.
	function normalizeProperty( name, value, isStyle ) {
		var temp = new CKEDITOR.dom.element( &#39;span&#39; );
		temp[ isStyle ? &#39;setStyle&#39; : &#39;setAttribute&#39; ]( name, value );
		return temp[ isStyle ? &#39;getStyle&#39; : &#39;getAttribute&#39; ]( name );
	}

	// Compare two bunch of styles, with the speciality that value &#39;inherit&#39;
	// is treated as a wildcard which will match any value.
	// @param {Object/String} source
	// @param {Object/String} target
	function compareCssText( source, target ) {
		if ( typeof source == &#39;string&#39; )
			source = CKEDITOR.tools.parseCssText( source );
		if ( typeof target == &#39;string&#39; )
			target = CKEDITOR.tools.parseCssText( target, true );

		for ( var name in source ) {
			if ( !( name in target &amp;&amp; ( target[ name ] == source[ name ] || source[ name ] == &#39;inherit&#39; || target[ name ] == &#39;inherit&#39; ) ) )
				return false;
		}
		return true;
	}

	function applyStyleOnSelection( selection, remove ) {
		var doc = selection.document,
			ranges = selection.getRanges(),
			func = remove ? this.removeFromRange : this.applyToRange,
			range;

		var iterator = ranges.createIterator();
		while ( ( range = iterator.getNextRange() ) )
			func.call( this, range );

		selection.selectRanges( ranges );
		doc.removeCustomData( &#39;doc_processing_style&#39; );
	}
} )();

<span id='CKEDITOR-styleCommand-method-constructor'><span id='CKEDITOR-styleCommand'>/**
</span></span> * Generic style command. It applies a specific style when executed.
 *
 *		var boldStyle = new CKEDITOR.style( { element: &#39;strong&#39; } );
 *		// Register the &quot;bold&quot; command, which applies the bold style.
 *		editor.addCommand( &#39;bold&#39;, new CKEDITOR.dialogCommand( boldStyle ) );
 *
 * @class
 * @constructor Creates a styleCommand class instance.
 * @extends CKEDITOR.commandDefinition
 * @param {CKEDITOR.style} style The style to be applied when command is executed.
 * @param {Object} [ext] Additional command definition&#39;s properties.
 */
CKEDITOR.styleCommand = function( style, ext ) {
	this.style = style;
	this.allowedContent = style;
	this.requiredContent = style;

	CKEDITOR.tools.extend( this, ext, true );
};

<span id='CKEDITOR-styleCommand-method-exec'>/**
</span> * @param {CKEDITOR.editor} editor
 * @todo
 */
CKEDITOR.styleCommand.prototype.exec = function( editor ) {
	editor.focus();

	if ( this.state == CKEDITOR.TRISTATE_OFF )
		editor.applyStyle( this.style );
	else if ( this.state == CKEDITOR.TRISTATE_ON )
		editor.removeStyle( this.style );
};

<span id='CKEDITOR-stylesSet'>/**
</span> * Manages styles registration and loading. See also {@link CKEDITOR.config#stylesSet}.
 *
 *		// The set of styles for the &lt;b&gt;Styles&lt;/b&gt; combo.
 *		CKEDITOR.stylesSet.add( &#39;default&#39;, [
 *			// Block Styles
 *			{ name: &#39;Blue Title&#39;,		element: &#39;h3&#39;,		styles: { &#39;color&#39;: &#39;Blue&#39; } },
 *			{ name: &#39;Red Title&#39;,		element: &#39;h3&#39;,		styles: { &#39;color&#39;: &#39;Red&#39; } },
 *
 *			// Inline Styles
 *			{ name: &#39;Marker: Yellow&#39;,	element: &#39;span&#39;,	styles: { &#39;background-color&#39;: &#39;Yellow&#39; } },
 *			{ name: &#39;Marker: Green&#39;,	element: &#39;span&#39;,	styles: { &#39;background-color&#39;: &#39;Lime&#39; } },
 *
 *			// Object Styles
 *			{
 *				name: &#39;Image on Left&#39;,
 *				element: &#39;img&#39;,
 *				attributes: {
 *					style: &#39;padding: 5px; margin-right: 5px&#39;,
 *					border: &#39;2&#39;,
 *					align: &#39;left&#39;
 *				}
 *			}
 *		] );
 *
 * @since 3.2
 * @class
 * @singleton
 * @extends CKEDITOR.resourceManager
 */
CKEDITOR.stylesSet = new CKEDITOR.resourceManager( &#39;&#39;, &#39;stylesSet&#39; );

// Backward compatibility (#5025).
CKEDITOR.addStylesSet = CKEDITOR.tools.bind( CKEDITOR.stylesSet.add, CKEDITOR.stylesSet );
CKEDITOR.loadStylesSet = function( name, url, callback ) {
	CKEDITOR.stylesSet.addExternal( name, url, &#39;&#39; );
	CKEDITOR.stylesSet.load( name, callback );
};


<span id='CKEDITOR-editor-method-getStylesSet'>/**
</span> * Gets the current styleSet for this instance.
 *
 *		editor.getStylesSet( function( stylesDefinitions ) {} );
 *
 * See also {@link CKEDITOR.editor#stylesSet} event.
 *
 * @param {Function} callback The function to be called with the styles data.
 * @member CKEDITOR.editor
 */
CKEDITOR.editor.prototype.getStylesSet = function( callback ) {
	if ( !this._.stylesDefinitions ) {
		var editor = this,
			// Respect the backwards compatible definition entry
			configStyleSet = editor.config.stylesCombo_stylesSet || editor.config.stylesSet;

		// The false value means that none styles should be loaded.
		if ( configStyleSet === false ) {
			callback( null );
			return;
		}

		// #5352 Allow to define the styles directly in the config object
		if ( configStyleSet instanceof Array ) {
			editor._.stylesDefinitions = configStyleSet;
			callback( configStyleSet );
			return;
		}

		// Default value is &#39;default&#39;.
		if ( !configStyleSet )
			configStyleSet = &#39;default&#39;;

		var partsStylesSet = configStyleSet.split( &#39;:&#39; ),
			styleSetName = partsStylesSet[ 0 ],
			externalPath = partsStylesSet[ 1 ];

		CKEDITOR.stylesSet.addExternal( styleSetName, externalPath ? partsStylesSet.slice( 1 ).join( &#39;:&#39; ) : CKEDITOR.getUrl( &#39;styles.js&#39; ), &#39;&#39; );

		CKEDITOR.stylesSet.load( styleSetName, function( stylesSet ) {
			editor._.stylesDefinitions = stylesSet[ styleSetName ];
			callback( editor._.stylesDefinitions );
		} );
	} else
		callback( this._.stylesDefinitions );
};

<span id='CKEDITOR-style-property-includeReadonly'>/**
</span> * Indicates that fully selected read-only elements will be included when
 * applying the style (for inline styles only).
 *
 * @since 3.5
 * @property {Boolean} [includeReadonly=false]
 * @member CKEDITOR.style
 */

<span id='CKEDITOR-style-property-alwaysRemoveElement'>/**
</span> * Indicates that any matches element of this style will be eventually removed
 * when calling {@link CKEDITOR.editor#removeStyle}.
 *
 * @since 4.0
 * @property {Boolean} [alwaysRemoveElement=false]
 * @member CKEDITOR.style
 */

<span id='CKEDITOR-config-cfg-disableReadonlyStyling'>/**
</span> * Disables inline styling on read-only elements.
 *
 * @since 3.5
 * @cfg {Boolean} [disableReadonlyStyling=false]
 * @member CKEDITOR.config
 */

<span id='CKEDITOR-config-cfg-stylesSet'>/**
</span> * The &quot;styles definition set&quot; to use in the editor. They will be used in the
 * styles combo and the style selector of the div container.
 *
 * The styles may be defined in the page containing the editor, or can be
 * loaded on demand from an external file. In the second case, if this setting
 * contains only a name, the `styles.js` file will be loaded from the
 * CKEditor root folder (what ensures backward compatibility with CKEditor 4.0).
 *
 * Otherwise, this setting has the `name:url` syntax, making it
 * possible to set the URL from which loading the styles file.
 * Note that the `name` has to be equal to the name used in
 * {@link CKEDITOR.stylesSet#add} while registering styles set.
 *
 * **Note**: Since 4.1 it is possible to set `stylesSet` to `false`
 * to prevent loading any styles set.
 *
 *		// Do not load any file. Styles set is empty.
 *		config.stylesSet = false;
 *
 *		// Load the &#39;mystyles&#39; styles set from styles.js file.
 *		config.stylesSet = &#39;mystyles&#39;;
 *
 *		// Load the &#39;mystyles&#39; styles set from a relative URL.
 *		config.stylesSet = &#39;mystyles:/editorstyles/styles.js&#39;;
 *
 *		// Load from a full URL.
 *		config.stylesSet = &#39;mystyles:http://www.example.com/editorstyles/styles.js&#39;;
 *
 *		// Load from a list of definitions.
 *		config.stylesSet = [
 *			{ name: &#39;Strong Emphasis&#39;, element: &#39;strong&#39; },
 *			{ name: &#39;Emphasis&#39;, element: &#39;em&#39; },
 *			...
 *		];
 *
 * @since 3.3
 * @cfg {String/Array/Boolean} [stylesSet=&#39;default&#39;]
 * @member CKEDITOR.config
 */
</pre>
</body>
</html>
