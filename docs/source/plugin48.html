<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='global-property-'>/**
</span> * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or http://ckeditor.com/license
 */

CKEDITOR.plugins.add( &#39;link&#39;, {
	requires: &#39;dialog,fakeobjects&#39;,
	lang: &#39;af,ar,bg,bn,bs,ca,cs,cy,da,de,el,en,en-au,en-ca,en-gb,eo,es,et,eu,fa,fi,fo,fr,fr-ca,gl,gu,he,hi,hr,hu,id,is,it,ja,ka,km,ko,ku,lt,lv,mk,mn,ms,nb,nl,no,pl,pt,pt-br,ro,ru,si,sk,sl,sq,sr,sr-latn,sv,th,tr,ug,uk,vi,zh,zh-cn&#39;, // %REMOVE_LINE_CORE%
	icons: &#39;anchor,anchor-rtl,link,unlink&#39;, // %REMOVE_LINE_CORE%
	hidpi: true, // %REMOVE_LINE_CORE%
	onLoad: function() {
		// Add the CSS styles for anchor placeholders.
		var iconPath = CKEDITOR.getUrl( this.path + &#39;images&#39; + ( CKEDITOR.env.hidpi ? &#39;/hidpi&#39; : &#39;&#39; ) + &#39;/anchor.png&#39; ),
			baseStyle = &#39;background:url(&#39; + iconPath + &#39;) no-repeat %1 center;border:1px dotted #00f;background-size:16px;&#39;;

		var template = &#39;.%2 a.cke_anchor,&#39; +
			&#39;.%2 a.cke_anchor_empty&#39; +
			&#39;,.cke_editable.%2 a[name]&#39; +
			&#39;,.cke_editable.%2 a[data-cke-saved-name]&#39; +
			&#39;{&#39; +
				baseStyle +
				&#39;padding-%1:18px;&#39; +
				// Show the arrow cursor for the anchor image (FF at least).
				&#39;cursor:auto;&#39; +
			&#39;}&#39; +
			( CKEDITOR.plugins.link.synAnchorSelector ? ( &#39;a.cke_anchor_empty&#39; +
			&#39;{&#39; +
				// Make empty anchor selectable on IE.
				&#39;display:inline-block;&#39; +
				// IE11 doesn&#39;t display empty inline-block elements.
				( CKEDITOR.env.ie &amp;&amp; CKEDITOR.env.version &gt; 10 ? &#39;min-height:16px;vertical-align:middle&#39; : &#39;&#39; ) +
			&#39;}&#39;
			) : &#39;&#39; ) +
			&#39;.%2 img.cke_anchor&#39; +
			&#39;{&#39; +
				baseStyle +
				&#39;width:16px;&#39; +
				&#39;min-height:15px;&#39; +
				// The default line-height on IE.
				&#39;height:1.15em;&#39; +
				// Opera works better with &quot;middle&quot; (even if not perfect)
				&#39;vertical-align:&#39; + ( CKEDITOR.env.opera ? &#39;middle&#39; : &#39;text-bottom&#39; ) + &#39;;&#39; +
			&#39;}&#39;;

		// Styles with contents direction awareness.
		function cssWithDir( dir ) {
			return template.replace( /%1/g, dir == &#39;rtl&#39; ? &#39;right&#39; : &#39;left&#39; ).replace( /%2/g, &#39;cke_contents_&#39; + dir );
		}

		CKEDITOR.addCss( cssWithDir( &#39;ltr&#39; ) + cssWithDir( &#39;rtl&#39; ) );
	},

	init: function( editor ) {
		var allowed = &#39;a[!href]&#39;,
			required = &#39;a[href]&#39;;

		if ( CKEDITOR.dialog.isTabEnabled( editor, &#39;link&#39;, &#39;advanced&#39; ) )
			allowed = allowed.replace( &#39;]&#39;, &#39;,accesskey,charset,dir,id,lang,name,rel,tabindex,title,type]{*}(*)&#39; );
		if ( CKEDITOR.dialog.isTabEnabled( editor, &#39;link&#39;, &#39;target&#39; ) )
			allowed = allowed.replace( &#39;]&#39;, &#39;,target,onclick]&#39; );

		// Add the link and unlink buttons.
		editor.addCommand( &#39;link&#39;, new CKEDITOR.dialogCommand( &#39;link&#39;, {
			allowedContent: allowed,
			requiredContent: required
		} ) );
		editor.addCommand( &#39;anchor&#39;, new CKEDITOR.dialogCommand( &#39;anchor&#39;, {
			allowedContent: &#39;a[!name,id]&#39;,
			requiredContent: &#39;a[name]&#39;
		} ) );
		editor.addCommand( &#39;unlink&#39;, new CKEDITOR.unlinkCommand() );
		editor.addCommand( &#39;removeAnchor&#39;, new CKEDITOR.removeAnchorCommand() );

		editor.setKeystroke( CKEDITOR.CTRL + 76 /*L*/, &#39;link&#39; );

		if ( editor.ui.addButton ) {
			editor.ui.addButton( &#39;Link&#39;, {
				label: editor.lang.link.toolbar,
				command: &#39;link&#39;,
				toolbar: &#39;links,10&#39;
			} );
			editor.ui.addButton( &#39;Unlink&#39;, {
				label: editor.lang.link.unlink,
				command: &#39;unlink&#39;,
				toolbar: &#39;links,20&#39;
			} );
			editor.ui.addButton( &#39;Anchor&#39;, {
				label: editor.lang.link.anchor.toolbar,
				command: &#39;anchor&#39;,
				toolbar: &#39;links,30&#39;
			} );
		}

		CKEDITOR.dialog.add( &#39;link&#39;, this.path + &#39;dialogs/link.js&#39; );
		CKEDITOR.dialog.add( &#39;anchor&#39;, this.path + &#39;dialogs/anchor.js&#39; );

		editor.on( &#39;doubleclick&#39;, function( evt ) {
			var element = CKEDITOR.plugins.link.getSelectedLink( editor ) || evt.data.element;

			if ( !element.isReadOnly() ) {
				if ( element.is( &#39;a&#39; ) ) {
					evt.data.dialog = ( element.getAttribute( &#39;name&#39; ) &amp;&amp; ( !element.getAttribute( &#39;href&#39; ) || !element.getChildCount() ) ) ? &#39;anchor&#39; : &#39;link&#39;;
					editor.getSelection().selectElement( element );
				} else if ( CKEDITOR.plugins.link.tryRestoreFakeAnchor( editor, element ) )
					evt.data.dialog = &#39;anchor&#39;;
			}
		} );

		// If the &quot;menu&quot; plugin is loaded, register the menu items.
		if ( editor.addMenuItems ) {
			editor.addMenuItems( {
				anchor: {
					label: editor.lang.link.anchor.menu,
					command: &#39;anchor&#39;,
					group: &#39;anchor&#39;,
					order: 1
				},

				removeAnchor: {
					label: editor.lang.link.anchor.remove,
					command: &#39;removeAnchor&#39;,
					group: &#39;anchor&#39;,
					order: 5
				},

				link: {
					label: editor.lang.link.menu,
					command: &#39;link&#39;,
					group: &#39;link&#39;,
					order: 1
				},

				unlink: {
					label: editor.lang.link.unlink,
					command: &#39;unlink&#39;,
					group: &#39;link&#39;,
					order: 5
				}
			} );
		}

		// If the &quot;contextmenu&quot; plugin is loaded, register the listeners.
		if ( editor.contextMenu ) {
			editor.contextMenu.addListener( function( element, selection ) {
				if ( !element || element.isReadOnly() )
					return null;

				var anchor = CKEDITOR.plugins.link.tryRestoreFakeAnchor( editor, element );

				if ( !anchor &amp;&amp; !( anchor = CKEDITOR.plugins.link.getSelectedLink( editor ) ) )
					return null;

				var menu = {};

				if ( anchor.getAttribute( &#39;href&#39; ) &amp;&amp; anchor.getChildCount() )
					menu = { link: CKEDITOR.TRISTATE_OFF, unlink: CKEDITOR.TRISTATE_OFF };

				if ( anchor &amp;&amp; anchor.hasAttribute( &#39;name&#39; ) )
					menu.anchor = menu.removeAnchor = CKEDITOR.TRISTATE_OFF;

				return menu;
			} );
		}
	},

	afterInit: function( editor ) {
		// Register a filter to displaying placeholders after mode change.

		var dataProcessor = editor.dataProcessor,
			dataFilter = dataProcessor &amp;&amp; dataProcessor.dataFilter,
			htmlFilter = dataProcessor &amp;&amp; dataProcessor.htmlFilter,
			pathFilters = editor._.elementsPath &amp;&amp; editor._.elementsPath.filters;

		if ( dataFilter ) {
			dataFilter.addRules( {
				elements: {
					a: function( element ) {
						var attributes = element.attributes;
						if ( !attributes.name )
							return null;

						var isEmpty = !element.children.length;

						if ( CKEDITOR.plugins.link.synAnchorSelector ) {
							// IE needs a specific class name to be applied
							// to the anchors, for appropriate styling.
							var ieClass = isEmpty ? &#39;cke_anchor_empty&#39; : &#39;cke_anchor&#39;;
							var cls = attributes[ &#39;class&#39; ];
							if ( attributes.name &amp;&amp; ( !cls || cls.indexOf( ieClass ) &lt; 0 ) )
								attributes[ &#39;class&#39; ] = ( cls || &#39;&#39; ) + &#39; &#39; + ieClass;

							if ( isEmpty &amp;&amp; CKEDITOR.plugins.link.emptyAnchorFix ) {
								attributes.contenteditable = &#39;false&#39;;
								attributes[ &#39;data-cke-editable&#39; ] = 1;
							}
						} else if ( CKEDITOR.plugins.link.fakeAnchor &amp;&amp; isEmpty )
							return editor.createFakeParserElement( element, &#39;cke_anchor&#39;, &#39;anchor&#39; );

						return null;
					}
				}
			} );
		}

		if ( CKEDITOR.plugins.link.emptyAnchorFix &amp;&amp; htmlFilter ) {
			htmlFilter.addRules( {
				elements: {
					a: function( element ) {
						delete element.attributes.contenteditable;
					}
				}
			} );
		}

		if ( pathFilters ) {
			pathFilters.push( function( element, name ) {
				if ( name == &#39;a&#39; ) {
					if ( CKEDITOR.plugins.link.tryRestoreFakeAnchor( editor, element ) || ( element.getAttribute( &#39;name&#39; ) &amp;&amp; ( !element.getAttribute( &#39;href&#39; ) || !element.getChildCount() ) ) )
						return &#39;anchor&#39;;

				}
			} );
		}
	}
} );

<span id='CKEDITOR-plugins-link'>/**
</span> * Set of Link plugin helpers.
 *
 * @class
 * @singleton
 */
CKEDITOR.plugins.link = {
<span id='CKEDITOR-plugins-link-method-getSelectedLink'>	/**
</span>	 * Get the surrounding link element of the current selection.
	 *
	 *		CKEDITOR.plugins.link.getSelectedLink( editor );
	 *
	 *		// The following selections will all return the link element.
	 *
	 *		&lt;a href=&quot;#&quot;&gt;li^nk&lt;/a&gt;
	 *		&lt;a href=&quot;#&quot;&gt;[link]&lt;/a&gt;
	 *		text[&lt;a href=&quot;#&quot;&gt;link]&lt;/a&gt;
	 *		&lt;a href=&quot;#&quot;&gt;li[nk&lt;/a&gt;]
	 *		[&lt;b&gt;&lt;a href=&quot;#&quot;&gt;li]nk&lt;/a&gt;&lt;/b&gt;]
	 *		[&lt;a href=&quot;#&quot;&gt;&lt;b&gt;li]nk&lt;/b&gt;&lt;/a&gt;
	 *
	 * @since 3.2.1
	 * @param {CKEDITOR.editor} editor
	 */
	getSelectedLink: function( editor ) {
		var selection = editor.getSelection();
		var selectedElement = selection.getSelectedElement();
		if ( selectedElement &amp;&amp; selectedElement.is( &#39;a&#39; ) )
			return selectedElement;

		var range = selection.getRanges()[ 0 ];

		if ( range ) {
			range.shrink( CKEDITOR.SHRINK_TEXT );
			return editor.elementPath( range.getCommonAncestor() ).contains( &#39;a&#39;, 1 );
		}
		return null;
	},

<span id='CKEDITOR-plugins-link-method-getEditorAnchors'>	/**
</span>	 * Collects anchors available in the editor (i.e. used by the Link plugin).
	 * Note that the scope of search is different for inline (the &quot;global&quot; document) and
	 * classic (`iframe`-based) editors (the &quot;inner&quot; document).
	 *
	 * @since 4.3.3
	 * @param {CKEDITOR.editor} editor
	 * @returns {CKEDITOR.dom.element[]} An array of anchor elements.
	 */
	getEditorAnchors: function( editor ) {
		var editable = editor.editable(),

			// The scope of search for anchors is the entire document for inline editors
			// and editor&#39;s editable for classic editor/divarea (#11359).
			scope = ( editable.isInline() &amp;&amp; !editor.plugins.divarea ) ? editor.document : editable,

			links = scope.getElementsByTag( &#39;a&#39; ),
			anchors = [],
			i = 0,
			item;

		// Retrieve all anchors within the scope.
		while ( ( item = links.getItem( i++ ) ) ) {
			if ( item.data( &#39;cke-saved-name&#39; ) || item.hasAttribute( &#39;name&#39; ) ) {
				anchors.push( {
					name: item.data( &#39;cke-saved-name&#39; ) || item.getAttribute( &#39;name&#39; ),
					id: item.getAttribute( &#39;id&#39; )
				} );
			}
		}

		// Retrieve all &quot;fake anchors&quot; within the scope.
		if ( this.fakeAnchor ) {
			var imgs = scope.getElementsByTag( &#39;img&#39; );

			i = 0;

			while ( ( item = imgs.getItem( i++ ) ) ) {
				if ( ( item = this.tryRestoreFakeAnchor( editor, item ) ) ) {
					anchors.push( {
						name: item.getAttribute( &#39;name&#39; ),
						id: item.getAttribute( &#39;id&#39; )
					} );
				}
			}
		}

		return anchors;
	},

<span id='CKEDITOR-plugins-link-property-fakeAnchor'>	/**
</span>	 * Opera and WebKit do not make it possible to select empty anchors. Fake
	 * elements must be used for them.
	 *
	 * @readonly
	 * @property {Boolean}
	 */
	fakeAnchor: CKEDITOR.env.opera || CKEDITOR.env.webkit,

<span id='CKEDITOR-plugins-link-property-synAnchorSelector'>	/**
</span>	 * For browsers that do not support CSS3 `a[name]:empty()`. Note that IE9 is included because of #7783.
	 *
	 * @readonly
	 * @property {Boolean}
	 */
	synAnchorSelector: CKEDITOR.env.ie,

<span id='CKEDITOR-plugins-link-property-emptyAnchorFix'>	/**
</span>	 * For browsers that have editing issues with an empty anchor.
	 *
	 * @readonly
	 * @property {Boolean}
	 */
	emptyAnchorFix: CKEDITOR.env.ie &amp;&amp; CKEDITOR.env.version &lt; 8,

<span id='CKEDITOR-plugins-link-method-tryRestoreFakeAnchor'>	/**
</span>	 * Returns an element representing a real anchor restored from a fake anchor.
	 * 
	 * @param {CKEDITOR.editor} editor
	 * @param {CKEDITOR.dom.element} element
	 * @returns {CKEDITOR.dom.element} Restored anchor element or nothing if the 
	 * passed element was not a fake anchor.
	 */
	tryRestoreFakeAnchor: function( editor, element ) {
		if ( element &amp;&amp; element.data( &#39;cke-real-element-type&#39; ) &amp;&amp; element.data( &#39;cke-real-element-type&#39; ) == &#39;anchor&#39; ) {
			var link = editor.restoreRealElement( element );
			if ( link.data( &#39;cke-saved-name&#39; ) )
				return link;
		}
	}
};

// TODO Much probably there&#39;s no need to expose these as public objects.

CKEDITOR.unlinkCommand = function() {};
CKEDITOR.unlinkCommand.prototype = {
	exec: function( editor ) {
		var style = new CKEDITOR.style( { element: &#39;a&#39;, type: CKEDITOR.STYLE_INLINE, alwaysRemoveElement: 1 } );
		editor.removeStyle( style );
	},

	refresh: function( editor, path ) {
		// Despite our initial hope, document.queryCommandEnabled() does not work
		// for this in Firefox. So we must detect the state by element paths.

		var element = path.lastElement &amp;&amp; path.lastElement.getAscendant( &#39;a&#39;, true );

		if ( element &amp;&amp; element.getName() == &#39;a&#39; &amp;&amp; element.getAttribute( &#39;href&#39; ) &amp;&amp; element.getChildCount() )
			this.setState( CKEDITOR.TRISTATE_OFF );
		else
			this.setState( CKEDITOR.TRISTATE_DISABLED );
	},

	contextSensitive: 1,
	startDisabled: 1,
	requiredContent: &#39;a[href]&#39;
};

CKEDITOR.removeAnchorCommand = function() {};
CKEDITOR.removeAnchorCommand.prototype = {
	exec: function( editor ) {
		var sel = editor.getSelection(),
			bms = sel.createBookmarks(),
			anchor;
		if ( sel &amp;&amp; ( anchor = sel.getSelectedElement() ) &amp;&amp; ( CKEDITOR.plugins.link.fakeAnchor &amp;&amp; !anchor.getChildCount() ? CKEDITOR.plugins.link.tryRestoreFakeAnchor( editor, anchor ) : anchor.is( &#39;a&#39; ) ) )
			anchor.remove( 1 );
		else {
			if ( ( anchor = CKEDITOR.plugins.link.getSelectedLink( editor ) ) ) {
				if ( anchor.hasAttribute( &#39;href&#39; ) ) {
					anchor.removeAttributes( { name: 1, &#39;data-cke-saved-name&#39;: 1 } );
					anchor.removeClass( &#39;cke_anchor&#39; );
				} else
					anchor.remove( 1 );
			}
		}
		sel.selectBookmarks( bms );
	},
	requiredContent: &#39;a[name]&#39;
};

CKEDITOR.tools.extend( CKEDITOR.config, {
<span id='CKEDITOR-config-cfg-linkShowAdvancedTab'>	/**
</span>	 * Whether to show the Advanced tab in the Link dialog window.
	 *
	 * @cfg {Boolean} [linkShowAdvancedTab=true]
	 * @member CKEDITOR.config
	 */
	linkShowAdvancedTab: true,

<span id='CKEDITOR-config-cfg-linkShowTargetTab'>	/**
</span>	 * Whether to show the Target tab in the Link dialog window.
	 *
	 * @cfg {Boolean} [linkShowTargetTab=true]
	 * @member CKEDITOR.config
	 */
	linkShowTargetTab: true
} );
</pre>
</body>
</html>
