<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='global-property-'>/**
</span> * @license Copyright (c) 2003-2014, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or http://ckeditor.com/license
 */

( function() {
<span id='CKEDITOR-editable'>	/**
</span>	 * Editable class which provides all editing related activities by
	 * the `contenteditable` element, dynamically get attached to editor instance.
	 *
	 * @class CKEDITOR.editable
	 * @extends CKEDITOR.dom.element
	 */
	CKEDITOR.editable = CKEDITOR.tools.createClass( {
		base: CKEDITOR.dom.element,
<span id='CKEDITOR-editable-method-constructor'>		/**
</span>		 * The constructor hold only generic editable creation logic that are commonly shared among all different editable elements.
		 *
		 * @constructor Creates an editable class instance.
		 * @param {CKEDITOR.editor} editor The editor instance on which the editable operates.
		 * @param {HTMLElement/CKEDITOR.dom.element} element Any DOM element that been used as the editor&#39;s
		 * editing container, e.g. it could be either an HTML element with the `contenteditable` attribute
		 * set to the true that handles wysiwyg editing or a `&lt;textarea&gt;` element that handles source editing.
		 */
		$: function( editor, element ) {
			// Transform the element into a CKEDITOR.dom.element instance.
			this.base( element.$ || element );

			this.editor = editor;

<span id='CKEDITOR-editable-property-status'>			/**
</span>			 * Indicates editable initialization status. The following statuses are available:
			 *
			 *	* **unloaded**: the initial state; editable&#39;s instance has been created but
			 *	is not fully loaded (in particular has no data),
			 *	* **ready**: editable is fully initialized; `ready` status is set after
			 *	first {@link CKEDITOR.editor#method-setData} has been called.
			 *	* **detached**: the editable has been detached.
			 *
			 * @since 4.3.3
			 * @readonly
			 * @property {String}
			 */
			this.status = &#39;unloaded&#39;;

<span id='CKEDITOR-editable-property-hasFocus'>			/**
</span>			 * Indicate whether the editable element has gained focus.
			 *
			 * @property {Boolean} hasFocus
			 */
			this.hasFocus = false;

			// The bootstrapping logic.
			this.setup();
		},
		proto: {

			focus: function() {

				var active;

				// [Webkit] When DOM focus is inside of nested contenteditable elements,
				// apply focus on the main editable will compromise it&#39;s text selection.
				if ( CKEDITOR.env.webkit &amp;&amp; !this.hasFocus ) {
					// Restore focus on element which we cached (on selectionCheck) as previously active.
					active = this.editor._.previousActive || this.getDocument().getActive();
					if ( this.contains( active ) ) {
						active.focus();
						return;
					}
				}

				// [IE] Use instead &quot;setActive&quot; method to focus the editable if it belongs to
				// the host page document, to avoid bringing an unexpected scroll.
				try {
					this.$[ CKEDITOR.env.ie &amp;&amp; this.getDocument().equals( CKEDITOR.document ) ? &#39;setActive&#39; : &#39;focus&#39; ]();
				} catch ( e ) {
					// IE throws unspecified error when focusing editable after closing dialog opened on nested editable.
					if ( !CKEDITOR.env.ie )
						throw e;
				}

				// Remedy if Safari doens&#39;t applies focus properly. (#279)
				if ( CKEDITOR.env.safari &amp;&amp; !this.isInline() ) {
					active = CKEDITOR.document.getActive();
					if ( !active.equals( this.getWindow().getFrame() ) )
						this.getWindow().focus();

				}
			},

<span id='CKEDITOR-editable-method-on'>			/**
</span>			 * Overrides {@link CKEDITOR.dom.element#on} to have special `focus/blur` handling.
			 * The `focusin/focusout` events are used in IE to replace regular `focus/blur` events
			 * because we want to avoid the asynchronous nature of later ones.
			 */
			on: function( name, fn ) {
				var args = Array.prototype.slice.call( arguments, 0 );

				if ( CKEDITOR.env.ie &amp;&amp; ( /^focus|blur$/ ).exec( name ) ) {
					name = name == &#39;focus&#39; ? &#39;focusin&#39; : &#39;focusout&#39;;

					// The &quot;focusin/focusout&quot; events bubbled, e.g. If there are elements with layout
					// they fire this event when clicking in to edit them but it must be ignored
					// to allow edit their contents. (#4682)
					fn = isNotBubbling( fn, this );
					args[ 0 ] = name;
					args[ 1 ] = fn;
				}

				return CKEDITOR.dom.element.prototype.on.apply( this, args );
			},

<span id='CKEDITOR-editable-method-attachListener'>			/**
</span>			 * Registers an event listener that needs to be removed when detaching this editable.
			 * This means that it will be automatically removed when {@link #detach} is executed,
			 * for example on {@link CKEDITOR.editor#setMode changing editor mode} or destroying editor.
			 *
			 * Except for `obj` all other arguments have the same meaning as in {@link CKEDITOR.event#on}.
			 *
			 * This method is strongly related to the {@link CKEDITOR.editor#contentDom} and
			 * {@link CKEDITOR.editor#contentDomUnload} events, because they are fired
			 * when an editable is being attached and detached. Therefore, this method is usually used
			 * in the following way:
			 *
			 *		editor.on( &#39;contentDom&#39;, function() {
			 *			var editable = editor.editable();
			 *			editable.attachListener( editable, &#39;mousedown&#39;, function() {
			 *				// ...
			 *			} );
			 *		} );
			 *
			 * This code will attach the `mousedown` listener every time a new editable is attached
			 * to the editor, which in classic (`iframe`-based) editor happens every time the
			 * data or the mode is set. This listener will also be removed when that editable is detached.
			 *
			 * It is also possible to attach a listener to another object (e.g. to a document).
			 *
			 *		editor.on( &#39;contentDom&#39;, function() {
			 *			editor.editable().attachListener( editor.document, &#39;mousedown&#39;, function() {
			 *				// ...
			 *			} );
			 *		} );
			 *
			 * @param {CKEDITOR.event} obj The element/object to which the listener will be attached. Every object
			 * which inherits from {@link CKEDITOR.event} may be used including {@link CKEDITOR.dom.element},
			 * {@link CKEDITOR.dom.document}, and {@link CKEDITOR.editable}.
			 * @param {String} eventName The name of the event that will be listened to.
			 * @param {Function} listenerFunction The function listening to the
			 * event. A single {@link CKEDITOR.eventInfo} object instance
			 * containing all the event data is passed to this function.
			 * @param {Object} [scopeObj] The object used to scope the listener
			 * call (the `this` object). If omitted, the current object is used.
			 * @param {Object} [listenerData] Data to be sent as the
			 * {@link CKEDITOR.eventInfo#listenerData} when calling the listener.
			 * @param {Number} [priority=10] The listener priority. Lower priority
			 * listeners are called first. Listeners with the same priority
			 * value are called in the registration order.
			 * @returns {Object} An object containing the `removeListener`
			 * function that can be used to remove the listener at any time.
			 */
			attachListener: function( obj, event, fn, scope, listenerData, priority ) {
				!this._.listeners &amp;&amp; ( this._.listeners = [] );
				// Register the listener.
				var args = Array.prototype.slice.call( arguments, 1 ),
					listener = obj.on.apply( obj, args );

				this._.listeners.push( listener );

				return listener;
			},

<span id='CKEDITOR-editable-method-clearListeners'>			/**
</span>			 * Remove all event listeners registered from {@link #attachListener}.
			 */
			clearListeners: function() {
				var listeners = this._.listeners;
				// Don&#39;t get broken by this.
				try {
					while ( listeners.length )
						listeners.pop().removeListener();
				} catch ( e ) {}
			},

<span id='CKEDITOR-editable-method-restoreAttrs'>			/**
</span>			 * Restore all attribution changes made by {@link #changeAttr }.
			 */
			restoreAttrs: function() {
				var changes = this._.attrChanges, orgVal;
				for ( var attr in changes ) {
					if ( changes.hasOwnProperty( attr ) ) {
						orgVal = changes[ attr ];
						// Restore original attribute.
						orgVal !== null ? this.setAttribute( attr, orgVal ) : this.removeAttribute( attr );
					}
				}
			},

<span id='CKEDITOR-editable-method-attachClass'>			/**
</span>			 * Adds a CSS class name to this editable that needs to be removed on detaching.
			 *
			 * @param {String} className The class name to be added.
			 * @see CKEDITOR.dom.element#addClass
			 */
			attachClass: function( cls ) {
				var classes = this.getCustomData( &#39;classes&#39; );
				if ( !this.hasClass( cls ) ) {
					!classes &amp;&amp; ( classes = [] ), classes.push( cls );
					this.setCustomData( &#39;classes&#39;, classes );
					this.addClass( cls );
				}
			},

<span id='CKEDITOR-editable-method-changeAttr'>			/**
</span>			 * Make an attribution change that would be reverted on editable detaching.
			 * @param {String} attr The attribute name to be changed.
			 * @param {String} val The value of specified attribute.
			 */
			changeAttr: function( attr, val ) {
				var orgVal = this.getAttribute( attr );
				if ( val !== orgVal ) {
					!this._.attrChanges &amp;&amp; ( this._.attrChanges = {} );

					// Saved the original attribute val.
					if ( !( attr in this._.attrChanges ) )
						this._.attrChanges[ attr ] = orgVal;

					this.setAttribute( attr, val );
				}
			},

<span id='CKEDITOR-editable-method-insertHtml'>			/**
</span>			 * @see CKEDITOR.editor#insertHtml
			 */
			insertHtml: function( data, mode ) {
				beforeInsert( this );
				// Default mode is &#39;html&#39;.
				insert( this, mode || &#39;html&#39;, data );
			},

<span id='CKEDITOR-editable-method-insertText'>			/**
</span>			 * @see CKEDITOR.editor#insertText
			 */
			insertText: function( text ) {
				beforeInsert( this );

				var editor = this.editor,
					mode = editor.getSelection().getStartElement().hasAscendant( &#39;pre&#39;, true ) ? CKEDITOR.ENTER_BR : editor.activeEnterMode,
					isEnterBrMode = mode == CKEDITOR.ENTER_BR,
					tools = CKEDITOR.tools;

				// CRLF -&gt; LF
				var html = tools.htmlEncode( text.replace( /\r\n/g, &#39;\n&#39; ) );

				// Tab -&gt; &amp;nbsp x 4;
				html = html.replace( /\t/g, &#39;&amp;nbsp;&amp;nbsp; &amp;nbsp;&#39; );

				var paragraphTag = mode == CKEDITOR.ENTER_P ? &#39;p&#39; : &#39;div&#39;;

				// Two line-breaks create one paragraphing block.
				if ( !isEnterBrMode ) {
					var duoLF = /\n{2}/g;
					if ( duoLF.test( html ) )
					{
						var openTag = &#39;&lt;&#39; + paragraphTag + &#39;&gt;&#39;, endTag = &#39;&lt;/&#39; + paragraphTag + &#39;&gt;&#39;;
						html = openTag + html.replace( duoLF, function() { return  endTag + openTag; } ) + endTag;
					}
				}

				// One &lt;br&gt; per line-break.
				html = html.replace( /\n/g, &#39;&lt;br&gt;&#39; );

				// Compensate padding &lt;br&gt; at the end of block, avoid loosing them during insertion.
				if ( !isEnterBrMode ) {
					html = html.replace( new RegExp( &#39;&lt;br&gt;(?=&lt;/&#39; + paragraphTag + &#39;&gt;)&#39; ), function( match ) {
						return tools.repeat( match, 2 );
					} );
				}

				// Preserve spaces at the ends, so they won&#39;t be lost after insertion (merged with adjacent ones).
				html = html.replace( /^ | $/g, &#39;&amp;nbsp;&#39; );

				// Finally, preserve whitespaces that are to be lost.
				html = html.replace( /(&gt;|\s) /g, function( match, before ) {
					return before + &#39;&amp;nbsp;&#39;;
				} ).replace( / (?=&lt;)/g, &#39;&amp;nbsp;&#39; );

				insert( this, &#39;text&#39;, html );
			},

<span id='CKEDITOR-editable-method-insertElement'>			/**
</span>			 * @see CKEDITOR.editor#insertElement
			 */
			insertElement: function( element, range ) {
				if ( !range )
					this.insertElementIntoSelection( element );
				else
					this.insertElementIntoRange( element, range );
			},

<span id='CKEDITOR-editable-method-insertElementIntoRange'>			/**
</span>			 * Inserts an element into the position in the editor determined by range.
			 *
			 * @param {CKEDITOR.dom.element} element The element to be inserted.
			 * @param {CKEDITOR.dom.range} range The range as a place of insertion.
			 * @returns {Boolean} Informs whether insertion was successful.
			 */
			insertElementIntoRange: function( element, range ) {
				var editor = this.editor,
					enterMode = editor.config.enterMode,
					elementName = element.getName(),
					isBlock = CKEDITOR.dtd.$block[ elementName ];

				if ( range.checkReadOnly() )
					return false;

				// Remove the original contents, merge split nodes.
				range.deleteContents( 1 );

				// If range is placed in inermediate element (not td or th), we need to do three things:
				// * fill emptied &lt;td/th&gt;s with if browser needs them,
				// * remove empty text nodes so IE8 won&#39;t crash (http://dev.ckeditor.com/ticket/11183#comment:8),
				// * fix structure and move range into the &lt;td/th&gt; element.
				if ( range.startContainer.type == CKEDITOR.NODE_ELEMENT &amp;&amp; range.startContainer.is( { tr: 1, table: 1, tbody: 1, thead: 1, tfoot: 1 } ) )
					fixTableAfterContentsDeletion( range );

				// If we&#39;re inserting a block at dtd-violated position, split
				// the parent blocks until we reach blockLimit.
				var current, dtd;

				if ( isBlock ) {
					while ( ( current = range.getCommonAncestor( 0, 1 ) ) &amp;&amp;
					        ( dtd = CKEDITOR.dtd[ current.getName() ] ) &amp;&amp;
					        !( dtd &amp;&amp; dtd[ elementName ] ) ) {

						// Split up inline elements.
						if ( current.getName() in CKEDITOR.dtd.span )
							range.splitElement( current );

						// If we&#39;re in an empty block which indicate a new paragraph,
						// simply replace it with the inserting block.(#3664)
						else if ( range.checkStartOfBlock() &amp;&amp; range.checkEndOfBlock() ) {
							range.setStartBefore( current );
							range.collapse( true );
							current.remove();
						} else
							range.splitBlock( enterMode == CKEDITOR.ENTER_DIV ? &#39;div&#39; : &#39;p&#39;, editor.editable() );
					}
				}

				// Insert the new node.
				range.insertNode( element );

				// Return true if insertion was successful.
				return true;
			},

<span id='CKEDITOR-editable-method-insertElementIntoSelection'>			/**
</span>			 * Inserts an element into the currently selected position in the editor.
			 *
			 * @param {CKEDITOR.dom.element} element The element to be inserted.
			 */
			insertElementIntoSelection: function( element ) {
				var editor = this.editor,
					enterMode = editor.activeEnterMode,
					selection = editor.getSelection(),
					range = selection.getRanges()[ 0 ],
					elementName = element.getName(),
					isBlock = CKEDITOR.dtd.$block[ elementName ];

				// Prepare for the insertion.
				beforeInsert( this );

				// Insert element into first range only and ignore the rest (#11183).
				if ( this.insertElementIntoRange( element, range ) ) {
					range.moveToPosition( element, CKEDITOR.POSITION_AFTER_END );

					// If we&#39;re inserting a block element, the new cursor position must be
					// optimized. (#3100,#5436,#8950)
					if ( isBlock ) {
						// Find next, meaningful element.
						var next = element.getNext( function( node ) {
							return isNotEmpty( node ) &amp;&amp; !isBogus( node );
						} );

						if ( next &amp;&amp; next.type == CKEDITOR.NODE_ELEMENT &amp;&amp; next.is( CKEDITOR.dtd.$block ) ) {
							// If the next one is a text block, move cursor to the start of it&#39;s content.
							if ( next.getDtd()[ &#39;#&#39; ] )
								range.moveToElementEditStart( next );
							// Otherwise move cursor to the before end of the last element.
							else
								range.moveToElementEditEnd( element );
						}
						// Open a new line if the block is inserted at the end of parent.
						else if ( !next &amp;&amp; enterMode != CKEDITOR.ENTER_BR ) {
							next = range.fixBlock( true, enterMode == CKEDITOR.ENTER_DIV ? &#39;div&#39; : &#39;p&#39; );
							range.moveToElementEditStart( next );
						}
					}
				}

				// Set up the correct selection.
				selection.selectRanges( [ range ] );

				afterInsert( this );
			},

<span id='CKEDITOR-editable-method-setData'>			/**
</span>			 * @see CKEDITOR.editor#setData
			 */
			setData: function( data, isSnapshot ) {
				if ( !isSnapshot )
					data = this.editor.dataProcessor.toHtml( data );

				this.setHtml( data );

				// Editable is ready after first setData.
				if ( this.status == &#39;unloaded&#39; )
					this.status = &#39;ready&#39;;

				this.editor.fire( &#39;dataReady&#39; );
			},

<span id='CKEDITOR-editable-method-getData'>			/**
</span>			 * @see CKEDITOR.editor#getData
			 */
			getData: function( isSnapshot ) {
				var data = this.getHtml();

				if ( !isSnapshot )
					data = this.editor.dataProcessor.toDataFormat( data );

				return data;
			},

<span id='CKEDITOR-editable-method-setReadOnly'>			/**
</span>			 * Change the read-only state on this editable.
			 *
			 * @param {Boolean} isReadOnly
			 */
			setReadOnly: function( isReadOnly ) {
				this.setAttribute( &#39;contenteditable&#39;, !isReadOnly );
			},

<span id='CKEDITOR-editable-method-detach'>			/**
</span>			 * Detach this editable object from the DOM (remove classes, listeners, etc.)
			 */
			detach: function() {
				// Cleanup the element.
				this.removeClass( &#39;cke_editable&#39; );

				this.status = &#39;detached&#39;;

				// Save the editor reference which will be lost after
				// calling detach from super class.
				var editor = this.editor;

				this._.detach();

				delete editor.document;
				delete editor.window;
			},

<span id='CKEDITOR-editable-method-isInline'>			/**
</span>			 * Check if the editable is one of the host page element, indicates the
			 * an inline editing environment.
			 *
			 * @returns {Boolean}
			 */
			isInline : function() {
				return this.getDocument().equals( CKEDITOR.document );
			},

<span id='CKEDITOR-editable-method-setup'>			/**
</span>			 * Editable element bootstrapping.
			 *
			 * @private
			 */
			setup: function() {
				var editor = this.editor;

				// Handle the load/read of editor data/snapshot.
				this.attachListener( editor, &#39;beforeGetData&#39;, function() {
					var data = this.getData();

					// Post processing html output of wysiwyg editable.
					if ( !this.is( &#39;textarea&#39; ) ) {
						// Reset empty if the document contains only one empty paragraph.
						if ( editor.config.ignoreEmptyParagraph !== false )
							data = data.replace( emptyParagraphRegexp, function( match, lookback ) { return lookback; } );
					}

					editor.setData( data, null, 1 );
				}, this );

				this.attachListener( editor, &#39;getSnapshot&#39;, function( evt ) {
					evt.data = this.getData( 1 );
				}, this );

				this.attachListener( editor, &#39;afterSetData&#39;, function() {
					this.setData( editor.getData( 1 ) );
				}, this );
				this.attachListener( editor, &#39;loadSnapshot&#39;, function( evt ) {
					this.setData( evt.data, 1 );
				}, this );

				// Delegate editor focus/blur to editable.
				this.attachListener( editor, &#39;beforeFocus&#39;, function() {
					var sel = editor.getSelection(),
						ieSel = sel &amp;&amp; sel.getNative();

					// IE considers control-type element as separate
					// focus host when selected, avoid destroying the
					// selection in such case. (#5812) (#8949)
					if ( ieSel &amp;&amp; ieSel.type == &#39;Control&#39; )
						return;

					this.focus();
				}, this );

				this.attachListener( editor, &#39;insertHtml&#39;, function( evt ) {
					this.insertHtml( evt.data.dataValue, evt.data.mode );
				}, this );
				this.attachListener( editor, &#39;insertElement&#39;, function( evt ) {
					this.insertElement( evt.data );
				}, this );
				this.attachListener( editor, &#39;insertText&#39;, function( evt ) {
					this.insertText( evt.data );
				}, this );

				// Update editable state.
				this.setReadOnly( editor.readOnly );

				// The editable class.
				this.attachClass( &#39;cke_editable&#39; );

				// The element mode css class.
				this.attachClass( editor.elementMode == CKEDITOR.ELEMENT_MODE_INLINE ?
					&#39;cke_editable_inline&#39; :
					editor.elementMode == CKEDITOR.ELEMENT_MODE_REPLACE ||
					editor.elementMode == CKEDITOR.ELEMENT_MODE_APPENDTO ?
					&#39;cke_editable_themed&#39; : &#39;&#39;
				);

				this.attachClass( &#39;cke_contents_&#39; + editor.config.contentsLangDirection );

				// Setup editor keystroke handlers on this element.
				var keystrokeHandler = editor.keystrokeHandler;

				// If editor is read-only, then make sure that BACKSPACE key
				// is blocked to prevent browser history navigation.
				keystrokeHandler.blockedKeystrokes[ 8 ] = +editor.readOnly;

				editor.keystrokeHandler.attach( this );

				// Update focus states.
				this.on( &#39;blur&#39;, function( evt ) {
					this.hasFocus = false;
				}, null, null, -1 );

				this.on( &#39;focus&#39;, function() {
					this.hasFocus = true;
				}, null, null, -1 );

				// Register to focus manager.
				editor.focusManager.add( this );

				// Inherit the initial focus on editable element.
				if ( this.equals( CKEDITOR.document.getActive() ) ) {
					this.hasFocus = true;
					// Pending until this editable has attached.
					editor.once( &#39;contentDom&#39;, function() {
						editor.focusManager.focus();
					} );
				}

				// Apply tab index on demand, with original direction saved.
				if ( this.isInline() ) {

					// tabIndex of the editable is different than editor&#39;s one.
					// Update the attribute of the editable.
					this.changeAttr( &#39;tabindex&#39;, editor.tabIndex );
				}

				// The above is all we&#39;ll be doing for a &lt;textarea&gt; editable.
				if ( this.is( &#39;textarea&#39; ) )
					return;

				// The DOM document which the editing acts upon.
				editor.document = this.getDocument();
				editor.window = this.getWindow();

				var doc = editor.document;

				this.changeAttr( &#39;spellcheck&#39;, !editor.config.disableNativeSpellChecker );

				// Apply contents direction on demand, with original direction saved.
				var dir = editor.config.contentsLangDirection;
				if ( this.getDirection( 1 ) != dir )
					this.changeAttr( &#39;dir&#39;, dir );

				// Create the content stylesheet for this document.
				var styles = CKEDITOR.getCss();
				if ( styles ) {
					var head = doc.getHead();
					if ( !head.getCustomData( &#39;stylesheet&#39; ) ) {
						var sheet = doc.appendStyleText( styles );
						sheet = new CKEDITOR.dom.element( sheet.ownerNode || sheet.owningElement );
						head.setCustomData( &#39;stylesheet&#39;, sheet );
						sheet.data( &#39;cke-temp&#39;, 1 );
					}
				}

				// Update the stylesheet sharing count.
				var ref = doc.getCustomData( &#39;stylesheet_ref&#39; ) || 0;
				doc.setCustomData( &#39;stylesheet_ref&#39;, ref + 1 );

				// Pass this configuration to styles system.
				this.setCustomData( &#39;cke_includeReadonly&#39;, !editor.config.disableReadonlyStyling );

				// Prevent the browser opening read-only links. (#6032 &amp; #10912)
				this.attachListener( this, &#39;click&#39;, function( evt ) {
					evt = evt.data;

					var link = new CKEDITOR.dom.elementPath( evt.getTarget(), this ).contains( &#39;a&#39; );

					if ( link &amp;&amp; evt.$.button != 2 &amp;&amp; link.isReadOnly() )
						evt.preventDefault();
				} );

				var backspaceOrDelete = { 8: 1, 46: 1 };

				// Override keystrokes which should have deletion behavior
				//  on fully selected element . (#4047) (#7645)
				this.attachListener( editor, &#39;key&#39;, function( evt ) {
					if ( editor.readOnly )
						return true;

					var keyCode = evt.data.keyCode, isHandled;

					// Backspace OR Delete.
					if ( keyCode in backspaceOrDelete ) {
						var sel = editor.getSelection(),
							selected,
							range = sel.getRanges()[ 0 ],
							path = range.startPath(),
							block,
							parent,
							next,
							rtl = keyCode == 8;

						if (
							// [IE&lt;11] Remove selected image/anchor/etc here to avoid going back in history. (#10055)
							( CKEDITOR.env.ie &amp;&amp; CKEDITOR.env.version &lt; 11 &amp;&amp; ( selected = sel.getSelectedElement() ) ) ||
							// Remove the entire list/table on fully selected content. (#7645)
							( selected = getSelectedTableList( sel ) )
						) {
							// Make undo snapshot.
							editor.fire( &#39;saveSnapshot&#39; );

							// Delete any element that &#39;hasLayout&#39; (e.g. hr,table) in IE8 will
							// break up the selection, safely manage it here. (#4795)
							range.moveToPosition( selected, CKEDITOR.POSITION_BEFORE_START );
							// Remove the control manually.
							selected.remove();
							range.select();

							editor.fire( &#39;saveSnapshot&#39; );

							isHandled = 1;
						} else if ( range.collapsed ) {
							// Handle the following special cases: (#6217)
							// 1. Del/Backspace key before/after table;
							// 2. Backspace Key after start of table.
							if ( ( block = path.block ) &amp;&amp;
								 ( next = block[ rtl ? &#39;getPrevious&#39; : &#39;getNext&#39; ]( isNotWhitespace ) ) &amp;&amp;
								 ( next.type == CKEDITOR.NODE_ELEMENT ) &amp;&amp;
								 next.is( &#39;table&#39; ) &amp;&amp;
								 range[ rtl ? &#39;checkStartOfBlock&#39; : &#39;checkEndOfBlock&#39; ]() )
							{
								editor.fire( &#39;saveSnapshot&#39; );

								// Remove the current empty block.
								if ( range[ rtl ? &#39;checkEndOfBlock&#39; : &#39;checkStartOfBlock&#39; ]() )
									block.remove();

								// Move cursor to the beginning/end of table cell.
								range[ &#39;moveToElementEdit&#39; + ( rtl ? &#39;End&#39; : &#39;Start&#39; ) ]( next );
								range.select();

								editor.fire( &#39;saveSnapshot&#39; );

								isHandled = 1;
							}
							else if ( path.blockLimit &amp;&amp; path.blockLimit.is( &#39;td&#39; ) &amp;&amp;
									  ( parent = path.blockLimit.getAscendant( &#39;table&#39; ) ) &amp;&amp;
									  range.checkBoundaryOfElement( parent, rtl ? CKEDITOR.START : CKEDITOR.END ) &amp;&amp;
									  ( next = parent[ rtl ? &#39;getPrevious&#39; : &#39;getNext&#39; ]( isNotWhitespace ) ) )
							{
								editor.fire( &#39;saveSnapshot&#39; );

								// Move cursor to the end of previous block.
								range[ &#39;moveToElementEdit&#39; + ( rtl ? &#39;End&#39; : &#39;Start&#39; ) ]( next );

								// Remove any previous empty block.
								if ( range.checkStartOfBlock() &amp;&amp; range.checkEndOfBlock() )
									next.remove();
								else
									range.select();

								editor.fire( &#39;saveSnapshot&#39; );

								isHandled = 1;
							}
							// BACKSPACE/DEL pressed at the start/end of table cell.
							else if ( ( parent = path.contains( [ &#39;td&#39;, &#39;th&#39;, &#39;caption&#39; ] ) ) &amp;&amp;
								      range.checkBoundaryOfElement( parent, rtl ? CKEDITOR.START : CKEDITOR.END ) ) {
								isHandled = 1;
							}
						}

					}

					return !isHandled;
				} );

				// On IE&gt;=11 we need to fill blockless editable with &lt;br&gt; if it was deleted.
				if ( editor.blockless &amp;&amp; CKEDITOR.env.ie &amp;&amp; CKEDITOR.env.needsBrFiller ) {
					this.attachListener( this, &#39;keyup&#39;, function( evt ) {
						if ( evt.data.getKeystroke() in backspaceOrDelete &amp;&amp; !this.getFirst( isNotEmpty ) ) {
							this.appendBogus();

							// Set the selection before bogus, because IE tends to put it after.
							var range = editor.createRange();
							range.moveToPosition( this, CKEDITOR.POSITION_AFTER_START );
							range.select();
						}
					} );
				}

				this.attachListener( this, &#39;dblclick&#39;, function( evt ) {
					if ( editor.readOnly )
						return false;

					var data = { element: evt.data.getTarget() };
					editor.fire( &#39;doubleclick&#39;, data );
				} );

				// Prevent automatic submission in IE #6336
				CKEDITOR.env.ie &amp;&amp; this.attachListener( this, &#39;click&#39;, blockInputClick );

				// Gecko/Webkit need some help when selecting control type elements. (#3448)
				if ( !CKEDITOR.env.ie ) {
					this.attachListener( this, &#39;mousedown&#39;, function( ev ) {
						var control = ev.data.getTarget();
						// #11727. Note: htmlDP assures that input/textarea/select have contenteditable=false
						// attributes. However, they also have data-cke-editable attribute, so isReadOnly() returns false,
						// and therefore those elements are correctly selected by this code.
						if ( control.is( &#39;img&#39;, &#39;hr&#39;, &#39;input&#39;, &#39;textarea&#39;, &#39;select&#39; ) &amp;&amp; !control.isReadOnly() ) {
							editor.getSelection().selectElement( control );

							// Prevent focus from stealing from the editable. (#9515)
							if ( control.is( &#39;input&#39;, &#39;textarea&#39;, &#39;select&#39; ) )
								ev.data.preventDefault();
						}
					} );
				}

				// Prevent right click from selecting an empty block even
				// when selection is anchored inside it. (#5845)
				if ( CKEDITOR.env.gecko ) {
					this.attachListener( this, &#39;mouseup&#39;, function( ev ) {
						if ( ev.data.$.button == 2 ) {
							var target = ev.data.getTarget();

							if ( !target.getOuterHtml().replace( emptyParagraphRegexp, &#39;&#39; ) ) {
								var range = editor.createRange();
								range.moveToElementEditStart( target );
								range.select( true );
							}
						}
					} );
				}

				// Webkit: avoid from editing form control elements content.
				if ( CKEDITOR.env.webkit ) {
					// Prevent from tick checkbox/radiobox/select
					this.attachListener( this, &#39;click&#39;, function( ev ) {
						if ( ev.data.getTarget().is( &#39;input&#39;, &#39;select&#39; ) )
							ev.data.preventDefault();
					} );

					// Prevent from editig textfield/textarea value.
					this.attachListener( this, &#39;mouseup&#39;, function( ev ) {
						if ( ev.data.getTarget().is( &#39;input&#39;, &#39;textarea&#39; ) )
							ev.data.preventDefault();
					} );
				}
			}
		},

		_: {
			detach: function() {
				// Update the editor cached data with current data.
				this.editor.setData( this.editor.getData(), 0, 1 );

				this.clearListeners();
				this.restoreAttrs();

				// Cleanup our custom classes.
				var classes;
				if ( ( classes = this.removeCustomData( &#39;classes&#39; ) ) ) {
					while ( classes.length )
						this.removeClass( classes.pop() );
				}

				// Remove contents stylesheet from document if it&#39;s the last usage.
				if ( !this.is( &#39;textarea&#39; ) ) {
					var doc = this.getDocument(),
						head = doc.getHead();
					if ( head.getCustomData( &#39;stylesheet&#39; ) ) {
						var refs = doc.getCustomData( &#39;stylesheet_ref&#39; );
						if ( !( --refs ) ) {
							doc.removeCustomData( &#39;stylesheet_ref&#39; );
							var sheet = head.removeCustomData( &#39;stylesheet&#39; );
							sheet.remove();
						} else
							doc.setCustomData( &#39;stylesheet_ref&#39;, refs );
					}
				}

				this.editor.fire( &#39;contentDomUnload&#39; );

				// Free up the editor reference.
				delete this.editor;
			}
		}
	} );

<span id='CKEDITOR-editor-method-editable'>	/**
</span>	 * Create, retrieve or detach an editable element of the editor,
	 * this method should always be used instead of calling directly {@link CKEDITOR.editable}.
	 *
	 * @method editable
	 * @member CKEDITOR.editor
	 * @param {CKEDITOR.dom.element/CKEDITOR.editable} elementOrEditable The
	 * DOM element to become the editable or a {@link CKEDITOR.editable} object.
	 */
	CKEDITOR.editor.prototype.editable = function( element ) {
		var editable = this._.editable;

		// This editor has already associated with
		// an editable element, silently fails.
		if ( editable &amp;&amp; element )
			return 0;

		if ( arguments.length ) {
			editable = this._.editable = element ? ( element instanceof CKEDITOR.editable ? element : new CKEDITOR.editable( this, element ) ) :
			// Detach the editable from editor.
			( editable &amp;&amp; editable.detach(), null );
		}

		// Just retrieve the editable.
		return editable;
	};

	// Auto-fixing block-less content by wrapping paragraph (#3190), prevent
	// non-exitable-block by padding extra br.(#3189)
	// Returns truly value when dom was changed, falsy otherwise.
	function fixDom( evt ) {
		var editor = evt.editor,
			path = evt.data.path,
			blockLimit = path.blockLimit,
			selection = evt.data.selection,
			range = selection.getRanges()[ 0 ],
			enterMode = editor.activeEnterMode,
			selectionUpdateNeeded;

		if ( CKEDITOR.env.gecko || ( CKEDITOR.env.ie &amp;&amp; CKEDITOR.env.needsBrFiller ) ) {
			var blockNeedsFiller = needsBrFiller( selection, path );
			if ( blockNeedsFiller ) {
				blockNeedsFiller.appendBogus();
				// IE tends to place selection after appended bogus, so we need to
				// select the original range (placed before bogus).
				selectionUpdateNeeded = CKEDITOR.env.ie;
			}
		}

		// When we&#39;re in block enter mode, a new paragraph will be established
		// to encapsulate inline contents inside editable. (#3657)
		// Don&#39;t autoparagraph if browser (namely - IE) incorrectly anchored selection
		// inside non-editable content. This happens e.g. if non-editable block is the only
		// content of editable.
		if ( shouldAutoParagraph( editor, path.block, blockLimit ) &amp;&amp; range.collapsed &amp;&amp; !range.getCommonAncestor().isReadOnly() ) {
			var testRng = range.clone();
			testRng.enlarge( CKEDITOR.ENLARGE_BLOCK_CONTENTS );
			var walker = new CKEDITOR.dom.walker( testRng );
			walker.guard = function( node ) {
				return !isNotEmpty( node ) ||
				       node.type == CKEDITOR.NODE_COMMENT ||
				       node.isReadOnly();
			};

			// 1. Inline content discovered under cursor;
			// 2. Empty editable.
			if ( !walker.checkForward() ||
			     testRng.checkStartOfBlock() &amp;&amp; testRng.checkEndOfBlock() ) {

				var fixedBlock = range.fixBlock( true, editor.activeEnterMode == CKEDITOR.ENTER_DIV ? &#39;div&#39; : &#39;p&#39; );

				// For IE&lt;11, we should remove any filler node which was introduced before.
				if ( !CKEDITOR.env.needsBrFiller ) {
					var first = fixedBlock.getFirst( isNotEmpty );
					if ( first &amp;&amp; isNbsp( first ) )
						first.remove();
				}

				selectionUpdateNeeded = 1;

				// Cancel this selection change in favor of the next (correct). (#6811)
				evt.cancel();
			}
		}

		if ( selectionUpdateNeeded )
			range.select();
	}

	// Checks whether current selection requires br filler to be appended.
	// @returns Block which needs filler or falsy value.
	function needsBrFiller( selection, path ) {
		// Fake selection does not need filler, because it is fake.
		if ( selection.isFake )
			return 0;

		// Ensure bogus br could help to move cursor (out of styles) to the end of block. (#7041)
		var pathBlock = path.block || path.blockLimit,
			lastNode = pathBlock &amp;&amp; pathBlock.getLast( isNotEmpty );

		// Check some specialities of the current path block:
		// 1. It is really displayed as block; (#7221)
		// 2. It doesn&#39;t end with one inner block; (#7467)
		// 3. It doesn&#39;t have bogus br yet.
		if (
			pathBlock &amp;&amp; pathBlock.isBlockBoundary() &amp;&amp;
			!( lastNode &amp;&amp; lastNode.type == CKEDITOR.NODE_ELEMENT &amp;&amp; lastNode.isBlockBoundary() ) &amp;&amp;
			!pathBlock.is( &#39;pre&#39; ) &amp;&amp; !pathBlock.getBogus()
		)
			return pathBlock;
	}

	function blockInputClick( evt ) {
		var element = evt.data.getTarget();
		if ( element.is( &#39;input&#39; ) ) {
			var type = element.getAttribute( &#39;type&#39; );
			if ( type == &#39;submit&#39; || type == &#39;reset&#39; )
				evt.data.preventDefault();
		}
	}

	function isBlankParagraph( block ) {
		return block.getOuterHtml().match( emptyParagraphRegexp );
	}

	function isNotEmpty( node ) {
		return isNotWhitespace( node ) &amp;&amp; isNotBookmark( node );
	}

	function isNbsp( node ) {
		return node.type == CKEDITOR.NODE_TEXT &amp;&amp; CKEDITOR.tools.trim( node.getText() ).match( /^(?:&amp;nbsp;|\xa0)$/ );
	}

	// Elements that could blink the cursor anchoring beside it, like hr, page-break. (#6554)
	function nonEditable( element ) {
		return element.isBlockBoundary() &amp;&amp; CKEDITOR.dtd.$empty[ element.getName() ];
	}

	function isNotBubbling( fn, src ) {
		return function( evt ) {
			var other = CKEDITOR.dom.element.get( evt.data.$.toElement || evt.data.$.fromElement || evt.data.$.relatedTarget );
			if ( !( other &amp;&amp; ( src.equals( other ) || src.contains( other ) ) ) )
				fn.call( this, evt );
		};
	}

	var isBogus = CKEDITOR.dom.walker.bogus();

	// Check if the entire table/list contents is selected.
	function getSelectedTableList( sel ) {
		var selected,
			range = sel.getRanges()[ 0 ],
			editable = sel.root,
			path = range.startPath(),
			structural = { table: 1, ul: 1, ol: 1, dl: 1 };

		if ( path.contains( structural ) ) {
			function guard( forwardGuard ) {
				return function( node, isWalkOut ) {
					// Save the encountered node as selected if going down the DOM structure
					// and the node is structured element.
					if ( isWalkOut &amp;&amp; node.type == CKEDITOR.NODE_ELEMENT &amp;&amp; node.is( structural ) )
						selected = node;

					// Stop the walker when either traversing another non-empty node at the same
					// DOM level as in previous step.
					// NOTE: When going forwards, stop if encountered a bogus.
					if ( !isWalkOut &amp;&amp; isNotEmpty( node ) &amp;&amp; !( forwardGuard &amp;&amp; isBogus( node ) ) )
						return false;
				};
			}

			// Clone the original range.
			var walkerRng = range.clone();

			// Enlarge the range: X&lt;ul&gt;&lt;li&gt;[Y]&lt;/li&gt;&lt;/ul&gt;X =&gt; [X&lt;ul&gt;&lt;li&gt;]Y&lt;/li&gt;&lt;/ul&gt;X
			walkerRng.collapse( 1 );
			walkerRng.setStartAt( editable, CKEDITOR.POSITION_AFTER_START );

			// Create a new walker.
			var walker = new CKEDITOR.dom.walker( walkerRng );

			// Assign a new guard to the walker.
			walker.guard = guard();

			// Go backwards checking for selected structural node.
			walker.checkBackward();

			// If there&#39;s a selected structured element when checking backwards,
			// then check the same forwards.
			if ( selected ) {
				// Clone the original range.
				walkerRng = range.clone();

				// Enlarge the range (assuming &lt;ul&gt; is selected element from guard):
				//
				// 	   X&lt;ul&gt;&lt;li&gt;[Y]&lt;/li&gt;&lt;/ul&gt;X    =&gt;    X&lt;ul&gt;&lt;li&gt;Y[&lt;/li&gt;&lt;/ul&gt;]X
				//
				// If the walker went deeper down DOM than a while ago when traversing
				// backwards, then it doesn&#39;t make sense: an element must be selected
				// symmetrically. By placing range end **after previously selected node**,
				// we make sure we don&#39;t go no deeper in DOM when going forwards.
				walkerRng.collapse();
				walkerRng.setEndAt( selected, CKEDITOR.POSITION_AFTER_END );

				// Create a new walker.
				walker = new CKEDITOR.dom.walker( walkerRng );

				// Assign a new guard to the walker.
				walker.guard = guard( true );

				// Reset selected node.
				selected = false;

				// Go forwards checking for selected structural node.
				walker.checkForward();

				return selected;
			}
		}

		return null;
	}

	// Whether in given context (pathBlock, pathBlockLimit and editor settings)
	// editor should automatically wrap inline contents with blocks.
	function shouldAutoParagraph( editor, pathBlock, pathBlockLimit ) {
		return editor.config.autoParagraph !== false &amp;&amp;
			editor.activeEnterMode != CKEDITOR.ENTER_BR &amp;&amp;
			editor.editable().equals( pathBlockLimit ) &amp;&amp; !pathBlock;
	}

	// Matching an empty paragraph at the end of document.
	var emptyParagraphRegexp = /(^|&lt;body\b[^&gt;]*&gt;)\s*&lt;(p|div|address|h\d|center|pre)[^&gt;]*&gt;\s*(?:&lt;br[^&gt;]*&gt;|&amp;nbsp;|\u00A0|&amp;#160;)?\s*(:?&lt;\/\2&gt;)?\s*(?=$|&lt;\/body&gt;)/gi;

	var isNotWhitespace = CKEDITOR.dom.walker.whitespaces( true ),
		isNotBookmark = CKEDITOR.dom.walker.bookmark( false, true );

	CKEDITOR.on( &#39;instanceLoaded&#39;, function( evt ) {
		var editor = evt.editor;

		// and flag that the element was locked by our code so it&#39;ll be editable by the editor functions (#6046).
		editor.on( &#39;insertElement&#39;, function( evt ) {
			var element = evt.data;
			if ( element.type == CKEDITOR.NODE_ELEMENT &amp;&amp; ( element.is( &#39;input&#39; ) || element.is( &#39;textarea&#39; ) ) ) {
				// // The element is still not inserted yet, force attribute-based check.
				if ( element.getAttribute( &#39;contentEditable&#39; ) != &quot;false&quot; )
					element.data( &#39;cke-editable&#39;, element.hasAttribute( &#39;contenteditable&#39; ) ? &#39;true&#39; : &#39;1&#39; );
				element.setAttribute( &#39;contentEditable&#39;, false );
			}
		} );

		editor.on( &#39;selectionChange&#39;, function( evt ) {
			if ( editor.readOnly )
				return;

			// Auto fixing on some document structure weakness to enhance usabilities. (#3190 and #3189)
			var sel = editor.getSelection();
			// Do it only when selection is not locked. (#8222)
			if ( sel &amp;&amp; !sel.isLocked ) {
				var isDirty = editor.checkDirty();

				// Lock undoM before touching DOM to prevent
				// recording these changes as separate snapshot.
				editor.fire( &#39;lockSnapshot&#39; );
				fixDom( evt );
				editor.fire( &#39;unlockSnapshot&#39; );

				!isDirty &amp;&amp; editor.resetDirty();
			}
		} );
	} );


	CKEDITOR.on( &#39;instanceCreated&#39;, function( evt ) {
		var editor = evt.editor;

		editor.on( &#39;mode&#39;, function() {

			var editable = editor.editable();

			// Setup proper ARIA roles and properties for inline editable, classic
			// (iframe-based) editable is instead handled by plugin.
			if ( editable &amp;&amp; editable.isInline() ) {

				var ariaLabel = editor.title;

				editable.changeAttr( &#39;role&#39;, &#39;textbox&#39; );
				editable.changeAttr( &#39;aria-label&#39;, ariaLabel );

				if ( ariaLabel )
					editable.changeAttr( &#39;title&#39;, ariaLabel );

				// Put the voice label in different spaces, depending on element mode, so
				// the DOM element get auto detached on mode reload or editor destroy.
				var ct = this.ui.space( this.elementMode == CKEDITOR.ELEMENT_MODE_INLINE ? &#39;top&#39; : &#39;contents&#39; );
				if ( ct ) {
					var ariaDescId = CKEDITOR.tools.getNextId(),
						desc = CKEDITOR.dom.element.createFromHtml( &#39;&lt;span id=&quot;&#39; + ariaDescId + &#39;&quot; class=&quot;cke_voice_label&quot;&gt;&#39; + this.lang.common.editorHelp + &#39;&lt;/span&gt;&#39; );
					ct.append( desc );
					editable.changeAttr( &#39;aria-describedby&#39;, ariaDescId );
				}
			}
		} );
	} );

	// #9222: Show text cursor in Gecko.
	// Show default cursor over control elements on all non-IEs.
	CKEDITOR.addCss( &#39;.cke_editable{cursor:text}.cke_editable img,.cke_editable input,.cke_editable textarea{cursor:default}&#39; );

	//
	// Functions related to insertXXX methods
	//
	var insert = ( function() {
		&#39;use strict&#39;;

		var DTD = CKEDITOR.dtd;

		// Inserts the given (valid) HTML into the range position (with range content deleted),
		// guarantee it&#39;s result to be a valid DOM tree.
		function insert( editable, type, data ) {
			var editor = editable.editor,
				doc = editable.getDocument(),
				selection = editor.getSelection(),
				// HTML insertion only considers the first range.
				// Note: getRanges will be overwritten for tests since we want to test
				// 		custom ranges and bypass native selections.
				// TODO what should we do with others? Remove?
				range = selection.getRanges()[ 0 ],
				dontFilter = false;

			if ( type == &#39;unfiltered_html&#39; ) {
				type = &#39;html&#39;;
				dontFilter = true;
			}

			// Check range spans in non-editable.
			if ( range.checkReadOnly() )
				return;

			// RANGE PREPARATIONS

			var path = new CKEDITOR.dom.elementPath( range.startContainer, range.root ),
				// Let root be the nearest block that&#39;s impossible to be split
				// during html processing.
				blockLimit = path.blockLimit || range.root,
				// The &quot;state&quot; value.
				that = {
					type: type,
					dontFilter: dontFilter,
					editable: editable,
					editor: editor,
					range: range,
					blockLimit: blockLimit,
					// During pre-processing / preparations startContainer of affectedRange should be placed
					// in this element in which inserted or moved (in case when we merge blocks) content
					// could create situation that will need merging inline elements.
					// Examples:
					// &lt;div&gt;&lt;b&gt;A&lt;/b&gt;^B&lt;/div&gt; + &lt;b&gt;C&lt;/b&gt; =&gt; &lt;div&gt;&lt;b&gt;A&lt;/b&gt;&lt;b&gt;C&lt;/b&gt;B&lt;/div&gt; - affected container is &lt;div&gt;.
					// &lt;p&gt;&lt;b&gt;A[B&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;C]D&lt;/b&gt;&lt;/p&gt; + E =&gt; &lt;p&gt;&lt;b&gt;AE&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;D&lt;/b&gt;&lt;/p&gt; =&gt;
					//		&lt;p&gt;&lt;b&gt;AE&lt;/b&gt;&lt;b&gt;D&lt;/b&gt;&lt;/p&gt; - affected container is &lt;p&gt; (in text mode).
					mergeCandidates: [],
					zombies: []
				};

			prepareRangeToDataInsertion( that );

			// DATA PROCESSING

			// Select range and stop execution.
			// If data has been totally emptied after the filtering,
			// any insertion is pointless (#10339).
			if ( data &amp;&amp; processDataForInsertion( that, data ) ) {
				// DATA INSERTION
				insertDataIntoRange( that );
			}

			// FINAL CLEANUP
			// Set final range position and clean up.

			cleanupAfterInsertion( that );

			// Make the final range selection.
			range.select();

			afterInsert( editable );
		}

		// Prepare range to its data deletion.
		// Delete its contents.
		// Prepare it to insertion.
		function prepareRangeToDataInsertion( that ) {
			var range = that.range,
				mergeCandidates = that.mergeCandidates,
				node, marker, path, startPath, endPath, previous, bm;

			// If range starts in inline element then insert a marker, so empty
			// inline elements won&#39;t be removed while range.deleteContents
			// and we will be able to move range back into this element.
			// E.g. &#39;aa&lt;b&gt;[bb&lt;/b&gt;]cc&#39; -&gt; (after deleting) &#39;aa&lt;b&gt;&lt;span/&gt;&lt;/b&gt;cc&#39;
			if ( that.type == &#39;text&#39; &amp;&amp; range.shrink( CKEDITOR.SHRINK_ELEMENT, true, false ) ) {
				marker = CKEDITOR.dom.element.createFromHtml( &#39;&lt;span&gt;&amp;nbsp;&lt;/span&gt;&#39;, range.document );
				range.insertNode( marker );
				range.setStartAfter( marker );
			}

			// By using path we can recover in which element was startContainer
			// before deleting contents.
			// Start and endPathElements will be used to squash selected blocks, after removing
			// selection contents. See rule 5.
			startPath = new CKEDITOR.dom.elementPath( range.startContainer );
			that.endPath = endPath = new CKEDITOR.dom.elementPath( range.endContainer );

			if ( !range.collapsed ) {
				// Anticipate the possibly empty block at the end of range after deletion.
				node = endPath.block || endPath.blockLimit;
				var ancestor = range.getCommonAncestor();
				if ( node &amp;&amp; !( node.equals( ancestor ) || node.contains( ancestor ) ) &amp;&amp;
				     range.checkEndOfBlock() ) {
					that.zombies.push( node );
				}

				range.deleteContents();
			}

			// Rule 4.
			// Move range into the previous block.
			while (
				( previous = getRangePrevious( range ) ) &amp;&amp; checkIfElement( previous ) &amp;&amp; previous.isBlockBoundary() &amp;&amp;
				// Check if previousNode was parent of range&#39;s startContainer before deleteContents.
				startPath.contains( previous )
			)
				range.moveToPosition( previous, CKEDITOR.POSITION_BEFORE_END );

			// Rule 5.
			mergeAncestorElementsOfSelectionEnds( range, that.blockLimit, startPath, endPath );

			// Rule 1.
			if ( marker ) {
				// If marker was created then move collapsed range into its place.
				range.setEndBefore( marker );
				range.collapse();
				marker.remove();
			}

			// Split inline elements so HTML will be inserted with its own styles.
			path = range.startPath();
			if ( ( node = path.contains( isInline, false, 1 ) ) ) {
				range.splitElement( node );
				that.inlineStylesRoot = node;
				that.inlineStylesPeak = path.lastElement;
			}

			// Record inline merging candidates for later cleanup in place.
			bm = range.createBookmark();

			// 1. Inline siblings.
			node = bm.startNode.getPrevious( isNotEmpty );
			node &amp;&amp; checkIfElement( node ) &amp;&amp; isInline( node ) &amp;&amp; mergeCandidates.push( node );
			node = bm.startNode.getNext( isNotEmpty );
			node &amp;&amp; checkIfElement( node ) &amp;&amp; isInline( node ) &amp;&amp; mergeCandidates.push( node );

			// 2. Inline parents.
			node = bm.startNode;
			while ( ( node = node.getParent() ) &amp;&amp; isInline( node ) )
				mergeCandidates.push( node );

			range.moveToBookmark( bm );
		}

		function processDataForInsertion( that, data ) {
			var range = that.range;

			// Rule 8. - wrap entire data in inline styles.
			// (e.g. &lt;p&gt;&lt;b&gt;x^z&lt;/b&gt;&lt;/p&gt; + &lt;p&gt;a&lt;/p&gt;&lt;p&gt;b&lt;/p&gt; -&gt; &lt;b&gt;&lt;p&gt;a&lt;/p&gt;&lt;p&gt;b&lt;/p&gt;&lt;/b&gt;)
			// Incorrect tags order will be fixed by htmlDataProcessor.
			if ( that.type == &#39;text&#39; &amp;&amp; that.inlineStylesRoot )
				data = wrapDataWithInlineStyles( data, that );


			var context = that.blockLimit.getName();

			// Wrap data to be inserted, to avoid loosing leading whitespaces
			// when going through the below procedure.
			if ( /^\s+|\s+$/.test( data ) &amp;&amp; &#39;span&#39; in CKEDITOR.dtd[ context ] ) {
				var protect = &#39;&lt;span data-cke-marker=&quot;1&quot;&gt;&amp;nbsp;&lt;/span&gt;&#39;;
				data =  protect + data + protect;
			}

			// Process the inserted html, in context of the insertion root.
			// Don&#39;t use the &quot;fix for body&quot; feature as auto paragraphing must
			// be handled during insertion.
			data = that.editor.dataProcessor.toHtml( data, {
				context: null,
				fixForBody: false,
				dontFilter: that.dontFilter,
				// Use the current, contextual settings.
				filter: that.editor.activeFilter,
				enterMode: that.editor.activeEnterMode
			} );


			// Build the node list for insertion.
			var doc = range.document,
				wrapper = doc.createElement( &#39;body&#39; );

			wrapper.setHtml( data );

			// Eventually remove the temporaries.
			if ( protect ) {
				wrapper.getFirst().remove();
				wrapper.getLast().remove();
			}

			// Rule 7.
			var block = range.startPath().block;
			if ( block &amp;&amp;													// Apply when there exists path block after deleting selection&#39;s content...
				!( block.getChildCount() == 1 &amp;&amp; block.getBogus() ) ) {		// ... and the only content of this block isn&#39;t a bogus.
				stripBlockTagIfSingleLine( wrapper );
			}

			that.dataWrapper = wrapper;

			return data;
		}

		function insertDataIntoRange( that ) {
			var range = that.range,
				doc = range.document,
				path,
				blockLimit = that.blockLimit,
				nodesData, nodeData, node,
				nodeIndex = 0,
				bogus,
				bogusNeededBlocks = [],
				pathBlock, fixBlock,
				splittingContainer = 0,
				dontMoveCaret = 0,
				insertionContainer, toSplit, newContainer,
				startContainer = range.startContainer,
				endContainer = that.endPath.elements[ 0 ],
				filteredNodes,
				// If endContainer was merged into startContainer: &lt;p&gt;a[b&lt;/p&gt;&lt;p&gt;c]d&lt;/p&gt;
				// or it&#39;s equal to startContainer: &lt;p&gt;a^b&lt;/p&gt;
				// or different situation happened :P
				// then there&#39;s no separate container for the end of selection.
				pos = endContainer.getPosition( startContainer ),
				separateEndContainer = !!endContainer.getCommonAncestor( startContainer ) // endC is not detached.
				&amp;&amp; pos != CKEDITOR.POSITION_IDENTICAL &amp;&amp; !( pos &amp; CKEDITOR.POSITION_CONTAINS + CKEDITOR.POSITION_IS_CONTAINED ); // endC &amp; endS are in separate branches.

			nodesData = extractNodesData( that.dataWrapper, that );

			removeBrsAdjacentToPastedBlocks( nodesData, range );

			for ( ; nodeIndex &lt; nodesData.length; nodeIndex++ ) {
				nodeData = nodesData[ nodeIndex ];

				// Ignore trailing &lt;brs&gt;
				if ( nodeData.isLineBreak &amp;&amp; splitOnLineBreak( range, blockLimit, nodeData ) ) {
					// Do not move caret towards the text (in cleanupAfterInsertion),
					// because caret was placed after a line break.
					dontMoveCaret = nodeIndex &gt; 0;
					continue;
				}

				path = range.startPath();

				// Auto paragraphing.
				if ( !nodeData.isBlock &amp;&amp; shouldAutoParagraph( that.editor, path.block, path.blockLimit ) &amp;&amp; ( fixBlock = autoParagraphTag( that.editor ) ) ) {
					fixBlock = doc.createElement( fixBlock );
					fixBlock.appendBogus();
					range.insertNode( fixBlock );
					if ( CKEDITOR.env.needsBrFiller &amp;&amp; ( bogus = fixBlock.getBogus() ) )
						bogus.remove();
					range.moveToPosition( fixBlock, CKEDITOR.POSITION_BEFORE_END );
				}

				node = range.startPath().block;

				// Remove any bogus element on the current path block for now, and mark
				// it for later compensation.
				if ( node &amp;&amp; !node.equals( pathBlock ) ) {
					bogus = node.getBogus();
					if ( bogus ) {
						bogus.remove();
						bogusNeededBlocks.push( node );
					}

					pathBlock = node;
				}

				// First not allowed node reached - start splitting original container
				if ( nodeData.firstNotAllowed )
					splittingContainer = 1;

				if ( splittingContainer &amp;&amp; nodeData.isElement ) {
					insertionContainer = range.startContainer;
					toSplit = null;

					// Find the first ancestor that can contain current node.
					// This one won&#39;t be split.
					while ( insertionContainer &amp;&amp; !DTD[ insertionContainer.getName() ][ nodeData.name ] ) {
						if ( insertionContainer.equals( blockLimit ) ) {
							insertionContainer = null;
							break;
						}

						toSplit = insertionContainer;
						insertionContainer = insertionContainer.getParent();
					}

					// If split has to be done - do it and mark both ends as a possible zombies.
					if ( insertionContainer ) {
						if ( toSplit ) {
							newContainer = range.splitElement( toSplit );
							that.zombies.push( newContainer );
							that.zombies.push( toSplit );
						}
					}
					// Unable to make the insertion happen in place, resort to the content filter.
					else {
						// If everything worked fine insertionContainer == blockLimit here.
						filteredNodes = filterElement( nodeData.node, blockLimit.getName(), !nodeIndex, nodeIndex == nodesData.length - 1 );
					}
				}

				if ( filteredNodes ) {
					while ( ( node = filteredNodes.pop() ) )
						range.insertNode( node );
					filteredNodes = 0;
				} else
					// Insert current node at the start of range.
					range.insertNode( nodeData.node );

				// Move range to the endContainer for the final allowed elements.
				if ( nodeData.lastNotAllowed &amp;&amp; nodeIndex &lt; nodesData.length - 1 ) {
					// If separateEndContainer exists move range there.
					// Otherwise try to move range to container created during splitting.
					// If this doesn&#39;t work - don&#39;t move range.
					newContainer = separateEndContainer ? endContainer : newContainer;
					newContainer &amp;&amp; range.setEndAt( newContainer, CKEDITOR.POSITION_AFTER_START );
					splittingContainer = 0;
				}

				// Collapse range after insertion to end.
				range.collapse();
			}

			that.dontMoveCaret = dontMoveCaret;
			that.bogusNeededBlocks = bogusNeededBlocks;
		}

		function cleanupAfterInsertion( that ) {
			var range = that.range,
				node, testRange, parent, movedIntoInline,
				bogusNeededBlocks = that.bogusNeededBlocks,
				// Create a bookmark to defend against the following range deconstructing operations.
				bm = range.createBookmark();

			// Remove all elements that could be created while splitting nodes
			// with ranges at its start|end.
			// E.g. remove &lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;
			// But not &lt;div&gt;&lt;p&gt; &lt;/p&gt;&lt;/div&gt;
			// And replace &lt;div&gt;&lt;p&gt;&lt;span data=&quot;cke-bookmark&quot;/&gt;&lt;/p&gt;&lt;/div&gt; with found bookmark.
			while ( ( node = that.zombies.pop() ) ) {
				// Detached element.
				if ( !node.getParent() )
					continue;

				testRange = range.clone();
				testRange.moveToElementEditStart( node );
				testRange.removeEmptyBlocksAtEnd();
			}

			if ( bogusNeededBlocks ) {
				// Bring back all block bogus nodes.
				while ( ( node = bogusNeededBlocks.pop() ) ) {
					if ( CKEDITOR.env.needsBrFiller )
						node.appendBogus();
					else
						node.append( range.document.createText( &#39;\u00a0&#39; ) );
				}
			}

			// Eventually merge identical inline elements.
			while ( ( node = that.mergeCandidates.pop() ) )
				node.mergeSiblings();

			range.moveToBookmark( bm );

			// Rule 3.
			// Shrink range to the BEFOREEND of previous innermost editable node in source order.

			if ( !that.dontMoveCaret ) {
				node = getRangePrevious( range );

				while ( node &amp;&amp; checkIfElement( node ) &amp;&amp; !node.is( DTD.$empty ) ) {
					if ( node.isBlockBoundary() )
						range.moveToPosition( node, CKEDITOR.POSITION_BEFORE_END );
					else {
						// Don&#39;t move into inline element (which ends with a text node)
						// found which contains white-space at its end.
						// If not - move range&#39;s end to the end of this element.
						if ( isInline( node ) &amp;&amp; node.getHtml().match( /(\s|&amp;nbsp;)$/g ) ) {
							movedIntoInline = null;
							break;
						}

						movedIntoInline = range.clone();
						movedIntoInline.moveToPosition( node, CKEDITOR.POSITION_BEFORE_END );
					}

					node = node.getLast( isNotEmpty );
				}

				movedIntoInline &amp;&amp; range.moveToRange( movedIntoInline );
			}

		}

		//
		// HELPERS ------------------------------------------------------------
		//

		function autoParagraphTag( editor ) {
			return ( editor.activeEnterMode != CKEDITOR.ENTER_BR &amp;&amp; editor.config.autoParagraph !== false ) ? editor.activeEnterMode == CKEDITOR.ENTER_DIV ? &#39;div&#39; : &#39;p&#39; : false;
		}

		function checkIfElement( node ) {
			return node.type == CKEDITOR.NODE_ELEMENT;
		}

		function extractNodesData( dataWrapper, that ) {
			var node, sibling, nodeName, allowed,
				nodesData = [],
				startContainer = that.range.startContainer,
				path = that.range.startPath(),
				allowedNames = DTD[ startContainer.getName() ],
				nodeIndex = 0,
				nodesList = dataWrapper.getChildren(),
				nodesCount = nodesList.count(),
				firstNotAllowed = -1,
				lastNotAllowed = -1,
				lineBreak = 0,
				blockSibling;

			// Selection start within a list.
			var insideOfList = path.contains( DTD.$list );

			for ( ; nodeIndex &lt; nodesCount; ++nodeIndex ) {
				node = nodesList.getItem( nodeIndex );

				if ( checkIfElement( node ) ) {
					nodeName = node.getName();

					// Extract only the list items, when insertion happens
					// inside of a list, reads as rearrange list items. (#7957)
					if ( insideOfList &amp;&amp; nodeName in CKEDITOR.dtd.$list ) {
						nodesData = nodesData.concat( extractNodesData( node, that ) );
						continue;
					}

					allowed = !!allowedNames[ nodeName ];

					// Mark &lt;brs data-cke-eol=&quot;1&quot;&gt; at the beginning and at the end.
					if ( nodeName == &#39;br&#39; &amp;&amp; node.data( &#39;cke-eol&#39; ) &amp;&amp; ( !nodeIndex || nodeIndex == nodesCount - 1 ) ) {
						sibling = nodeIndex ? nodesData[ nodeIndex - 1 ].node : nodesList.getItem( nodeIndex + 1 );

						// Line break has to have sibling which is not an &lt;br&gt;.
						lineBreak = sibling &amp;&amp; ( !checkIfElement( sibling ) || !sibling.is( &#39;br&#39; ) );
						// Line break has block element as a sibling.
						blockSibling = sibling &amp;&amp; checkIfElement( sibling ) &amp;&amp; DTD.$block[ sibling.getName() ];
					}

					if ( firstNotAllowed == -1 &amp;&amp; !allowed )
						firstNotAllowed = nodeIndex;
					if ( !allowed )
						lastNotAllowed = nodeIndex;

					nodesData.push( {
						isElement: 1,
						isLineBreak: lineBreak,
						isBlock: node.isBlockBoundary(),
						hasBlockSibling: blockSibling,
						node: node,
						name: nodeName,
						allowed: allowed
					} );

					lineBreak = 0;
					blockSibling = 0;
				} else
					nodesData.push( { isElement: 0, node: node, allowed: 1 } );
			}

			// Mark first node that cannot be inserted directly into startContainer
			// and last node for which startContainer has to be split.
			if ( firstNotAllowed &gt; -1 )
				nodesData[ firstNotAllowed ].firstNotAllowed = 1;
			if ( lastNotAllowed &gt; -1 )
				nodesData[ lastNotAllowed ].lastNotAllowed = 1;

			return nodesData;
		}

		// TODO: Review content transformation rules on filtering element.
		function filterElement( element, parentName, isFirst, isLast ) {
			var nodes = filterElementInner( element, parentName ),
				nodes2 = [],
				nodesCount = nodes.length,
				nodeIndex = 0,
				node,
				afterSpace = 0,
				lastSpaceIndex = -1;

			// Remove duplicated spaces and spaces at the:
			// * beginnig if filtered element isFirst (isFirst that&#39;s going to be inserted)
			// * end if filtered element isLast.
			for ( ; nodeIndex &lt; nodesCount; nodeIndex++ ) {
				node = nodes[ nodeIndex ];

				if ( node == &#39; &#39; ) {
					// Don&#39;t push doubled space and if it&#39;s leading space for insertion.
					if ( !afterSpace &amp;&amp; !( isFirst &amp;&amp; !nodeIndex ) ) {
						nodes2.push( new CKEDITOR.dom.text( &#39; &#39; ) );
						lastSpaceIndex = nodes2.length;
					}
					afterSpace = 1;
				} else {
					nodes2.push( node );
					afterSpace = 0;
				}
			}

			// Remove trailing space.
			if ( isLast &amp;&amp; lastSpaceIndex == nodes2.length )
				nodes2.pop();

			return nodes2;
		}

		function filterElementInner( element, parentName ) {
			var nodes = [],
				children = element.getChildren(),
				childrenCount = children.count(),
				child,
				childIndex = 0,
				allowedNames = DTD[ parentName ],
				surroundBySpaces = !element.is( DTD.$inline ) || element.is( &#39;br&#39; );

			if ( surroundBySpaces )
				nodes.push( &#39; &#39; );

			for ( ; childIndex &lt; childrenCount; childIndex++ ) {
				child = children.getItem( childIndex );

				if ( checkIfElement( child ) &amp;&amp; !child.is( allowedNames ) )
					nodes = nodes.concat( filterElementInner( child, parentName ) );
				else
					nodes.push( child );
			}

			if ( surroundBySpaces )
				nodes.push( &#39; &#39; );

			return nodes;
		}

		function getRangePrevious( range ) {
			return checkIfElement( range.startContainer ) &amp;&amp; range.startContainer.getChild( range.startOffset - 1 );
		}

		function isInline( node ) {
			return node &amp;&amp; checkIfElement( node ) &amp;&amp; ( node.is( DTD.$removeEmpty ) || node.is( &#39;a&#39; ) &amp;&amp; !node.isBlockBoundary() );
		}

		var blockMergedTags = { p: 1, div: 1, h1: 1, h2: 1, h3: 1, h4: 1, h5: 1, h6: 1, ul: 1, ol: 1, li: 1, pre: 1, dl: 1, blockquote: 1 };

		// See rule 5. in TCs.
		// Initial situation:
		// &lt;ul&gt;&lt;li&gt;AA^&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;BB&lt;/li&gt;&lt;/ul&gt;
		// We&#39;re looking for 2nd &lt;ul&gt;, comparing with 1st &lt;ul&gt; and merging.
		// We&#39;re not merging if caret is between these elements.
		function mergeAncestorElementsOfSelectionEnds( range, blockLimit, startPath, endPath ) {
			var walkerRange = range.clone(),
				walker, nextNode, previousNode;

			walkerRange.setEndAt( blockLimit, CKEDITOR.POSITION_BEFORE_END );
			walker = new CKEDITOR.dom.walker( walkerRange );

			if ( ( nextNode = walker.next() )							// Find next source node
				&amp;&amp; checkIfElement( nextNode )							// which is an element
				&amp;&amp; blockMergedTags[ nextNode.getName() ]				// that can be merged.
				&amp;&amp; ( previousNode = nextNode.getPrevious() )			// Take previous one
				&amp;&amp; checkIfElement( previousNode )						// which also has to be an element.
				&amp;&amp; !previousNode.getParent().equals( range.startContainer ) // Fail if caret is on the same level.
																		// This means that caret is between these nodes.
				&amp;&amp; startPath.contains( previousNode )					// Elements path of start of selection has
				&amp;&amp; endPath.contains( nextNode )							// to contain prevNode and vice versa.
				&amp;&amp; nextNode.isIdentical( previousNode ) )				// Check if elements are identical.
			{
				// Merge blocks and repeat.
				nextNode.moveChildren( previousNode );
				nextNode.remove();
				mergeAncestorElementsOfSelectionEnds( range, blockLimit, startPath, endPath );
			}
		}

		// If last node that will be inserted is a block (but not a &lt;br&gt;)
		// and it will be inserted right before &lt;br&gt; remove this &lt;br&gt;.
		// Do the same for the first element that will be inserted and preceding &lt;br&gt;.
		function removeBrsAdjacentToPastedBlocks( nodesData, range ) {
			var succeedingNode = range.endContainer.getChild( range.endOffset ),
				precedingNode = range.endContainer.getChild( range.endOffset - 1 );

			if ( succeedingNode )
				remove( succeedingNode, nodesData[ nodesData.length - 1 ] );

			if ( precedingNode &amp;&amp; remove( precedingNode, nodesData[ 0 ] ) ) {
				// If preceding &lt;br&gt; was removed - move range left.
				range.setEnd( range.endContainer, range.endOffset - 1 );
				range.collapse();
			}

			function remove( maybeBr, maybeBlockData ) {
				if ( maybeBlockData.isBlock &amp;&amp; maybeBlockData.isElement &amp;&amp; !maybeBlockData.node.is( &#39;br&#39; ) &amp;&amp;
					checkIfElement( maybeBr ) &amp;&amp; maybeBr.is( &#39;br&#39; ) ) {
					maybeBr.remove();
					return 1;
				}
			}
		}

		// Return 1 if &lt;br&gt; should be skipped when inserting, 0 otherwise.
		function splitOnLineBreak( range, blockLimit, nodeData ) {
			var firstBlockAscendant, pos;

			if ( nodeData.hasBlockSibling )
				return 1;

			firstBlockAscendant = range.startContainer.getAscendant( DTD.$block, 1 );
			if ( !firstBlockAscendant || !firstBlockAscendant.is( { div: 1, p: 1 } ) )
				return 0;

			pos = firstBlockAscendant.getPosition( blockLimit );

			if ( pos == CKEDITOR.POSITION_IDENTICAL || pos == CKEDITOR.POSITION_CONTAINS )
				return 0;

			var newContainer = range.splitElement( firstBlockAscendant );
			range.moveToPosition( newContainer, CKEDITOR.POSITION_AFTER_START );

			return 1;
		}

		var stripSingleBlockTags = { p: 1, div: 1, h1: 1, h2: 1, h3: 1, h4: 1, h5: 1, h6: 1 },
			inlineButNotBr = CKEDITOR.tools.extend( {}, DTD.$inline );
		delete inlineButNotBr.br;

		// Rule 7.
		function stripBlockTagIfSingleLine( dataWrapper ) {
			var block, children;

			if ( dataWrapper.getChildCount() == 1 &amp;&amp;					// Only one node bein inserted.
				checkIfElement( block = dataWrapper.getFirst() ) &amp;&amp;		// And it&#39;s an element.
				block.is( stripSingleBlockTags ) )						// That&#39;s &lt;p&gt; or &lt;div&gt; or header.
			{
				// Check children not containing block.
				children = block.getElementsByTag( &#39;*&#39; );
				for ( var i = 0, child, count = children.count(); i &lt; count; i++ ) {
					child = children.getItem( i );
					if ( !child.is( inlineButNotBr ) )
						return;
				}

				block.moveChildren( block.getParent( 1 ) );
				block.remove();
			}
		}

		function wrapDataWithInlineStyles( data, that ) {
			var element = that.inlineStylesPeak,
				doc = element.getDocument(),
				wrapper = doc.createText( &#39;{cke-peak}&#39; ),
				limit = that.inlineStylesRoot.getParent();

			while ( !element.equals( limit ) ) {
				wrapper = wrapper.appendTo( element.clone() );
				element = element.getParent();
			}

			// Don&#39;t use String.replace because it fails in IE7 if special replacement
			// characters ($$, $&amp;, etc.) are in data (#10367).
			return wrapper.getOuterHtml().split( &#39;{cke-peak}&#39; ).join( data );
		}

		return insert;
	} )();

	function beforeInsert( editable ) {
		// TODO: For unknown reason we must call directly on the editable to put the focus immediately.
		editable.editor.focus();

		editable.editor.fire( &#39;saveSnapshot&#39; );
	}

	function afterInsert( editable ) {
		var editor = editable.editor;

		// Scroll using selection, not ranges, to affect native pastes.
		editor.getSelection().scrollIntoView();

		// Save snaps after the whole execution completed.
		// This&#39;s a workaround for make DOM modification&#39;s happened after
		// &#39;insertElement&#39; to be included either, e.g. Form-based dialogs&#39; &#39;commitContents&#39;
		// call.
		setTimeout( function() {
			editor.fire( &#39;saveSnapshot&#39; );
		}, 0 );
	}

	// 1. Fixes a range which is a result of deleteContents() and is placed in an intermediate element (see dtd.$intermediate),
	// inside a table. A goal is to find a closest &lt;td&gt; or &lt;th&gt; element and when this fails, recreate the structure of the table.
	// 2. Fixes empty cells by appending bogus &lt;br&gt;s or deleting empty text nodes in IE&lt;=8 case.
	var fixTableAfterContentsDeletion = ( function() {
		// Creates an element walker which can only &quot;go deeper&quot;. It won&#39;t
		// move out from any element. Therefore it can be used to find &lt;td&gt;x&lt;/td&gt; in cases like:
		// &lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;x&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;^&lt;tfoot&gt;...
		function getFixTableSelectionWalker( testRange ) {
			var walker = new CKEDITOR.dom.walker( testRange );
			walker.guard = function( node, isMovingOut ) {
				if ( isMovingOut )
					return false;
				if ( node.type == CKEDITOR.NODE_ELEMENT )
					return node.is( CKEDITOR.dtd.$tableContent );
			};
			walker.evaluator = function( node ) {
				return node.type == CKEDITOR.NODE_ELEMENT;
			};

			return walker;
		}

		function fixTableStructure( element, newElementName, appendToStart ) {
			var temp = element.getDocument().createElement( newElementName );
			element.append( temp, appendToStart );
			return temp;
		}

		// Fix empty cells. This means:
		// * add bogus &lt;br&gt; if browser needs it
		// * remove empty text nodes on IE8, because it will crash (http://dev.ckeditor.com/ticket/11183#comment:8).
		function fixEmptyCells( cells ) {
			var i = cells.count(),
				cell;

			for ( i; i-- &gt; 0; ) {
				cell = cells.getItem( i );

				if ( !CKEDITOR.tools.trim( cell.getHtml() ) ) {
					cell.appendBogus();
					if ( CKEDITOR.env.ie &amp;&amp; CKEDITOR.env.version &lt; 9 &amp;&amp; cell.getChildCount() )
						cell.getFirst().remove();
				}
			}
		}

		return function( range ) {
			var container = range.startContainer,
				table = container.getAscendant( &#39;table&#39;, 1 ),
				testRange,
				walker,
				deeperSibling,
				doc = range.document,
				appendToStart = false;

			fixEmptyCells( table.getElementsByTag( &#39;td&#39; ) );
			fixEmptyCells( table.getElementsByTag( &#39;th&#39; ) );

			// Look left.
			testRange = range.clone();
			testRange.setStart( container, 0 );
			deeperSibling = getFixTableSelectionWalker( testRange ).lastBackward();

			// If left is empty, look right.
			if ( !deeperSibling ) {
				testRange = range.clone();
				testRange.setEndAt( container, CKEDITOR.POSITION_BEFORE_END );
				deeperSibling = getFixTableSelectionWalker( testRange ).lastForward();
				appendToStart = true;
			}

			// If there&#39;s no deeper nested element in both direction - container is empty - we&#39;ll use it then.
			if ( !deeperSibling )
				deeperSibling = container;

			// Fix structure...

			// We found a table what means that it&#39;s empty - remove it completely.
			if ( deeperSibling.is( &#39;table&#39; ) ) {
				range.setStartAt( deeperSibling, CKEDITOR.POSITION_BEFORE_START );
				range.collapse( true );
				deeperSibling.remove();
				return;
			}

			// Found an empty txxx element - append tr.
			if ( deeperSibling.is( { tbody: 1, thead: 1, tfoot: 1 } ) )
				deeperSibling = fixTableStructure( deeperSibling, &#39;tr&#39;, appendToStart );

			// Found an empty tr element - append td/th.
			if ( deeperSibling.is( &#39;tr&#39; ) )
				deeperSibling = fixTableStructure( deeperSibling, deeperSibling.getParent().is( &#39;thead&#39; ) ? &#39;th&#39; : &#39;td&#39;, appendToStart );

			// To avoid setting selection after bogus, remove it from the current cell.
			// We can safely do that, because we&#39;ll insert element into that cell.
			var bogus = deeperSibling.getBogus();
			if ( bogus )
				bogus.remove();

			range.moveToPosition( deeperSibling, appendToStart ? CKEDITOR.POSITION_AFTER_START : CKEDITOR.POSITION_BEFORE_END );
		};
	} )();

} )();

<span id='CKEDITOR-config-cfg-ignoreEmptyParagraph'>/**
</span> * Whether the editor must output an empty value (`&#39;&#39;`) if it&#39;s contents is made
 * by an empty paragraph only.
 *
 *		config.ignoreEmptyParagraph = false;
 *
 * @cfg {Boolean} [ignoreEmptyParagraph=true]
 * @member CKEDITOR.config
 */

<span id='CKEDITOR-editable-event-focus'>/**
</span> * @event focus
 * @todo
 */

<span id='CKEDITOR-editable-event-blur'> /**
</span> * @event blur
 * @todo
 */
</pre>
</body>
</html>
